# MyBatis 源码剖析





# 第一部分自定义持久层框架

## 1.1分析jdb c操作问题

```java
public static void main(String[] args) {

    Connection connection = null;
    PreparedStatement preparedStatement = null;
    ResultSet resultSet = null;
    try {
        //加载数据库驱动
        Class.forName("com.mysql.jdbc.Driver");
        //通过驱动管理类获取数据库链接
        connection = DriverManager.getConnection("jdbc:mysql://localhost:3306/mybatis?characterEncoding=utf-8", "root", "root");

        //定义sql语句？表示占位符
        String sql = "select * from user where username = ?";
        //获取预处理statement
        preparedStatement = connection.prepareStatement(sql);
        //设置参数，第一个参数为sql语句中参数的序号(从1开始)，第二个参数为设置的参数值
        preparedStatement.setString(1, "tom");
        //向数据库发出sql执行查询，查询出结果集
        resultSet = preparedStatement.executeQuery();
        //遍历查询结果集
        while (resultSet.next()) {
            int id = resultSet.getInt("id");
            String username = resultSet.getString("username");
            //封装User
            user.setId(id);
            user.setUsername(username);
        }
        System.out.println(user);
    }
} catch (Exception e) {
    e.printStackTrace();
} finally {
    //释放资源
    if (resultSet != null) {
        try {
            resultSet.close();
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }
    if (preparedStatement != null) {
        try { 
            preparedStatement.close();
            } catch (SQLException e) {
            e.printStackTrace();
        }
    }
    if (connection != null) {
        try {
            connection.close();
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }
}
```



JDBC问题总结：

1、	数据库连接创建、释放频繁造成系统资源浪费，从而影响系统性能。

2、	Sql语句在代码中硬编码，造成代码不易维护，实际应用中sql变化的可能较大，sql变动需要改变 java代码。

3、	使用preparedStatement向占有位符号传参数存在硬编码，因为sql语句的where条件不一定，可能 多也可能少，修改sql还要修改代码，系统不易维护。

4、	对结果集解析存在硬编码(查询列名)，sql变化导致解析代码变化，系统不易维护，如果能将数据 库记录封装成pojo对象解析比较方便

## 1.2问题解决思路

数据库频繁创建连接、释放资源：连接池

sql语句及参数硬编码：配置文件

手动解析封装返回结果集：反射、内省

## 1.3自定义框架设计

使用端：

提供核心配置文件

sqlMapConfig.xml:存放数据源信息，引入 mapper.xml

Mapper.xml: sql语句的配置文件信息

框架端：

1. 读取配置文件 读取完以后以流的形式存在，我们不能讲读取到的配置信息以流的形式存放在内存中，不好操作，可以创建j avaBean来存储(1) Configuration:存放数据库基本信息、Map〈唯一标识,Mapper> 唯一标识：namespace+"."+id(2) MappedStatement: sql语句、statement类型、输入参数java类型、输出参数java类型2. 解析配置文件创建 SqISessionFactroyBuilder 类：方法：SqISessionFactory build():第一：使用dom4j解析配置文件，将解析出来的内容封装到Configuration和MappedStatement中第二：创建 SqlSessionFactory 的实现类 DefaultSqlSession3. 创建 SqlSessionFactory:方法：openSession()：获取sqlSession接口的实现类实例对象4. 创建SqlSession接口及实现类:主要封装CRU D方法方法：selectList(String StatementldQbject param):查询所有selectOne(String StatementldQbject param)： 查询单个close()释放资源具体实现：封装JDBC完成对数据库表的查询操作设计到的设计模式构建者模式、工厂模式、代理模式

## 1.4自定义框架实现

在使用端项目中创建配置配置文件创建 sqlMapConfig.xml

```xml
<configuration>
    <!--数据库连接信息-->
    <property name=HdriverClassH value=Hcom.mysql.jdbc.DriverH></property>
    <property name="jdbcUrl" value=Hjdbc:mysql:///zdy_mybatisH></property>
    <property name="user" value="root"></property>
    <property name="password" value="root"></property>
    <! --引入sql配置信息-->
    <mapper resource="mapper.xml"></mapper>
</configuration> 
```



```xml
<mapper namespace="User">
    <select id="selectOne" paramterType="com.lagou.pojo.User" resultType="com.lagou.pojo.User">
        select * from user where id = #{id} and username =#{username}
    </select>
    <select id="selectList" resultType="com.lagou.pojo.User">
        select * from user
    </select>
</mapper>
```

User实体

```java
public class User {
    //主键标识
    private Integer id;
    //用户名
    private String username;
    public Integer getId() {
        return id;
    }
    public void setId(Integer id) {
        this.id = id;
    }
    public String getUsername() {
        return username;
    }
    public void setUsername(String username) {
        this.username = username;
    }
    @Override
    public String toString() {
        return "User{" +"id=" + id +", username='" + username +	+'}';
    }
}
```





再创建一个Maven子工程并且导入需要用到的依赖坐标

```xml
<properties>
    <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding> 		     
    <maven.compiler.encoding>UTF-8</maven.compiler.encoding> 	
    <java.version>1.8</java.version>
    <maven.compiler.source>1.8</maven.compiler.source>
    <maven.compiler.target>1.8</maven.compiler.target> 
</properties>

<dependencies>
    <dependency><groupId>mysql</groupId> <artifactId>mysql-connector-java</artifactId> <version>5.1.17</version></dependency>
    <dependency><groupId>c3p0</groupId><artifactId>c3p0</artifactId><version>0.9.1.2</version></dependency>
    <dependency><groupId>log4j</groupId><artifactId>log4j</artifactId><version>1.2.12</version></dependency>
    <dependency><groupId>junit</groupId><artifactId>junit</artifactId><version>4.10</version></dependency>
    <dependency><groupId>dom4j</groupId><artifactId>dom4j</artifactId><version>1.6.1</version></dependency>
    <dependency><groupId>jaxen</groupId><artifactId>jaxen</artifactId> <version>1.1.6</version></dependency>
</dependencies>
```



Configuration

```java
public class Configuration {

    //数据源

    private DataSource dataSource;

    //map集合： key:statementId value:MappedStatement

    private Map<String,MappedStatement> mappedStatementMap = new HashMap<String, MappedStatement>();

    public DataSource getDataSource() {
        return dataSource;
    }

    public void setDataSource(DataSource dataSource) {
        this.dataSource = dataSource;
    }

    public Map<String, MappedStatement> getMappedStatementMap() { 
        return mappedStatementMap;
    }

    public void setMappedStatementMap(Map<String, MappedStatement> mappedStatementMap) {
        this.mappedStatementMap = mappedStatementMap;
    }

}


```





MappedStatement



public class MappedStatement {//idprivate Integer id;//sql语句private String sql;//输入参数private Class<?> paramterType;//输出参数private Class<?> resultType;public Integer getId() {return id;}public void setId(Integer id) {this.id = id;}public String getSql() {return sql;}public void setSql(String sql) {this.sql = sql;}public Class<?> getParamterType() {return paramterType;public void setParamterType(Class<?> paramterType) {this.paramterType = paramterType;}public Class<?> getResultType() {return resultType;}public void setResultType(Class<?> resultType) { this.resultType = resultType;}}Resourcespublic class Resources {public static InputStream getResourceAsSteam(String path){ InputStream resourceAsStream =Resources.class.getResourceAsStream(path); return resourceAsStream;}}SqlSessionFactoryBuilderpublic class SqlSessionFactoryBuilder {private Configuration configuration;public SqlSessionFactoryBuilder() { this.configuration = new Configuration();}public SqlSessionFactory build(InputStream inputStream) throws DocumentException, PropertyVetoException, ClassNotFoundException { //1.解析配置文件，封装ConfigurationXMLConfigerBuilder xmlConfigerBuilder = new XMLConfigerBuilder(configuration);Configuration configuration = xmlConfigerBuilder.parseConfiguration(inputStream);//2.创建 sqlSessionFactory SqlSessionFactory sqlSessionFactory = new DefaultSqlSessionFactory(configuration);return sqlSessionFactory;  XMLConfigerBuilderpublic class XMLConfigerBuilder {private Configuration configuration;public XMLConfigerBuilder(Configuration configuration) { this.configuration = new Configuration();}public Configuration parseConfiguration(InputStream inputStream) throwsDocumentException, PropertyVetoException, ClassNotFoundException {Document document = new SAXReader().read(inputStream); //<configuation>Element rootElement = document.getRootElement();List<Element> propertyElements = rootElement.selectNodes("//property");Properties properties = new Properties();for (Element propertyElement : propertyElements) {String name = propertyElement.attributeValue("name");String value = propertyElement.attributeValue("value");properties.setProperty(name,value);}//连接池ComboPooledDataSource comboPooledDataSource = newComboPooledDataSource();comboPooledDataSource.setDriverClass(properties.getProperty("driverClass")); comboPooledDataSource.setJdbcUrl(properties.getProperty("jdbcUrl")); comboPooledDataSource.setUser(properties.getProperty("username")); comboPooledDataSource.setPassword(properties.getProperty("password"));//填充 c onfiguration configuration.setDataSource(comboPooledDataSource);//mapper 部分List<Element> mapperElements = rootElement.selectNodes("//mapper");XMLMapperBuilder xmlMapperBuilder = newXMLMapperBuilder(configuration);for (Element mapperElement : mapperElements) {String mapperPath = mapperElement.attributeValue("resource");InputStream resourceAsSteam =Resources.getResourceAsSteam(mapperPath);xmlMapperBuilder.parse(resourceAsSteam);  }return configuration;XMLMapperBuilderpublic class XMLMapperBuilder {private Configuration configuration;public XMLMapperBuilder(Configuration configuration) {this.configuration = configuration;}public void parse(InputStream inputStream) throws DocumentException, ClassNotFoundException {Document document = new SAXReader().read(inputStream);Element rootElement = document.getRootElement();String namespace = rootElement.attributeValue("namespace"); List<Element> select = rootElement.selectNodes("select");for (Element element : select) {//id的值String id = element.attributeValue("id");String paramterType = element.attributeValue("paramterType");String resultType = element.attributeValue("resultType");//输入参数classClass<?> paramterTypeClass = getClassType(paramterType);//返回结果classClass<?> resultTypeClass = getClassType(resultType);//statementIdString key = namespace +"."+id;//sql语句String textTrim = element.getTextTrim();//封装 mappedStatementMappedStatement mappedStatement = new MappedStatement(); mappedStatement.setId(id); mappedStatement.setParamterType(paramterTypeClass); mappedStatement.setResultType(resultTypeClass); mappedStatement.setSql(textTrim);//填充 c onfiguration configuration.getMappedStatementMap().put(key,mappedStatement);}}  private Class<?> getClassType(String paramterType) throws ClassNotFoundException {Class<?> aClass = Class.forName(paramterType); return aClass;}sqlSessionFactory 接口及D efaultSqlSessionFactory 实现类public interface SqlSessionFactory {public SqlSession openSession();}public class DefaultSqlSessionFactory implements SqlSessionFactory {private Configuration configuration;public DefaultSqlSessionFactory(Configuration configuration) { this.configuration = configuration;}public SqlSession openSession(){return new DefaultSqlSession(configuration);}}sqlSession 接口及 DefaultSqlSession 实现类public interface SqlSession {public <E> List<E> selectList(String statementId, Object... param) Exception;public <T> T selectOne(String statementId,Object... params) throws Exception;public void close() throws SQLException;}public class DefaultSqlSession implements SqlSession {private Configuration configuration;public DefaultSqlSession(Configuration configuration) { this.configuration = configuration;〃处理器对象private Executor simpleExcutor = new SimpleExecutor();public <E> List<E> selectList(String statementId,Object... param) throws Exception{MappedStatement mappedstatement = configuration.getMappedStatementMap().get(statementId);List<E> query = simpleExcutor.query(configuration, mappedStatement, param);return query;}//selectOne 中调用 selectListpublic <T> T selectOne(String statementId,Object... params) throws Exception {List<Object> objects = selectList(statementId, params);if(objects.size() ==1){return (T) objects.get(0);}else {throw new RuntimeException("返回结果过多");}}public void close() throws SQLException {simpleExcutor.close();}}Executorpublic interface Executor {<E> List<E> query(Configuration configuration, MappedStatement mappedStatement,Object[] param) throws Exception;void close() throws SQLException;}SimpleExecutorpublic class SimpleExecutor implements Executor {private Connection connection = null;public <E> List<E> query(Configuration configuration, MappedStatement mappedStatement,Object[] param) throws SQLException, NoSuchFieldException, IllegalAccessException, InstantiationException, IntrospectionException, InvocationTargetException {〃获取连接connection = configuration.getDataSource().getConnection();// select * from user where id = #{id} and username = #{username} String sql = mappedstatement.getSql();//对sql进行处理BoundSql boundsql = getBoundSql(sql);// select * from where id = ? and username = ?String finalSql = boundsql.getSqlText();//获取传入参数类型Class<?> paramterType = mappedStatement.getParamterType();//获取预编译preparedStatement对象PreparedStatement preparedStatement = connection.prepareStatement(finalSql);List<ParameterMapping> parameterMappingList = boundsql.getParameterMappingList();for (int i = 0; i < parameterMappingList.size(); i++) { ParameterMapping parameterMapping = parameterMappingList.get(i); String name = parameterMapping.getName();//反射Field declaredField = paramterType.getDeclaredField(name); declaredField.setAccessible(true);〃参数的值Object o = declaredField.get(param[0]);//给占位符赋值preparedStatement.setobject(i+1,o);}ResultSet resultSet = preparedStatement.executeQuery();Class<?> resultType = mappedStatement.getResultType(); ArrayList<E> results = new ArrayList<E>();while (resultSet.next()){ResultSetMetaData metaData = resultSet.getMetaData();  E o = (E) resultType.newInstance();int columnCount = metaData.getColumnCount();for (int i = 1; i <= columnCount; i++) {//属性名String columnName = metaData.getColumnName(i);//属性值Object value = resultset.getObject(columnName);//创建属性描述器，为属性生成读写方法PropertyDescriptor propertyDescriptor = new PropertyDescriptor(columnName, resultType);//获取写方法Method writeMethod = propertyDescriptor.getWriteMethod();//向类中写入值writeMethod.invoke(o,value);}results.add(o);}return results;}@Overridepublic void close() throws SQLException {connection.close();}private BoundSql getBoundSql(String sql) {//标记处理类：主要是配合通用标记解析器GenericTokenParser类完成对配置文件等的解 析工作，其中TokenHandler主要完成处理ParameterMappingTokenHandler parameterMappingTokenHandler = new ParameterMappingTokenHandler();//GenericTokenParser :通用的标记解析器，完成了代码片段中的占位符的解析，然后再根 据给定的标记处理器(TokenHandler)来进行表达式的处理//三个参数：分别为openToken (开始标记)、closeToken (结束标记)、handler (标记处 理器)GenericTokenParser genericTokenParser = new GenericTokenParser。'# {","}",parameterMappingTokenHandler);String parse = genericTokenParser.parse(sql);List<ParameterMapping> parameterMappings = parameterMappingTokenHandler.getParameterMappings();BoundSql boundSql = new BoundSql(parse, parameterMappings);return boundSql;  BoundSqlpublic class BoundSql {//解析过后的sql语句private String sqlText;〃解析出来的参数private List<ParameterMapping> parameterMappingList = new ArrayList<ParameterMapping>();public BoundSql(String sqlText, List<ParameterMapping> parameterMappingList) {this.sqlText = sqlText;this.parameterMappingList = parameterMappingList;}public String getSqlText() {return sqlText;}public void setSqlText(String sqlText) {this.sqlText = sqlText;}public List<ParameterMapping> getParameterMappingList() {return parameterMappingList;}public void setParameterMappingList(List<ParameterMapping> parameterMappingList) {this.parameterMappingList = parameterMappingList;}}1.5自定义框架优化通过上述我们的自定义框架，我们解决了JDBC操作数据库带来的一些问题：例如频繁创建释放数据库连 接，硬编码，手动封装返回结果集等问题，但是现在我们继续来分析刚刚完成的自定义框架代码，有没 有什么问题？问题如下：• dao的实现类中存在重复的代码，整个操作的过程模板重复(创建sqlsession,调用sqlsession方 法，关闭 sqlsession)• dao的实现类中存在硬编码，调用sqlsession的方法时，参数statement的id硬编码 解决：使用代理模式来创建接口的代理对象  @Testpublic void test2() throws Exception{InputStream resourceAsSteam = Resources.getResourceAsSteam( path： "sqlMapConfig.xml") SqlSessionFactory build = new SqlSessionFactoryBuilder().build(resourceAsSteam); SqlSession sqlSession = build.openSession();User user = new User();user.setld(l);user.setUsername("tom");//代理对象UserMapper userMapper = sqlSession.getMappper(UserMapper.class);User userl = userMapper.selectOne(user);System・ out.println(userl);在sqlSession中添加方法public interface SqlSession {public <T> T getMappper(Class<?> mapperClass);实现类@Overridepublic <T> T getMappper(Class<?> mapperClass) {T o = (T) Proxy.newProxyInstance(mapperClass.getClassLoader(), new Class[]{mapperClass}, new InvocationHandler() {@Overridepublic Object invoke(Object proxy, Method method, Object[] args) throws Throwable {// selectOneString methodName = method.getName();// className:namespaceString className = method.getDeclaringClass().getName();//statementidString key = className+"."+methodName;MappedStatement mappedStatement =configuration.getMappedStatementMap().get(key);Type genericReturnType = method.getGenericReturnType();ArrayList arrayList = new ArrayList<> ();//判断是否实现泛型类型参数化if(genericReturnType instanceof ParameterizedType){ return selectList(key,args);  return selectOne(key,args);}})；return o;}第二部分Mybatis相关概念2.1对象/关系数据库映射（ORM）ORM全称Object/Relation Mapping：表示对象-关系映射的缩写ORM完成面向对象的编程语言到关系数据库的映射。当ORM框架完成映射后，程序员既可以利用面向 对象程序设计语言的简单易用性，又可以利用关系数据库的技术优势。ORM把关系数据库包装成面向对 象的模型。ORM框架是面向对象设计语言与关系数据库发展不同步时的中间解决方案。采用ORM框架 后，应用程序不再直接访问底层数据库，而是以面向对象的放松来操作持久化对象，而ORM框架则将这 些面向对象的操作转换成底层SQL操作。ORM框架实现的效果：把对持久化对象的保存、修改、删除 等操作，转换为对数据库的操作2.2 Mybatis 简介MyBatis是一款优秀的基于ORM的半自动轻量级持久层框架，它支持定制化SQL、存储过程以及高级映 射。MyBatis避免了几乎所有的JDBC代码和手动设置参数以及获取结果集。MyBatis可以使用简单的XML或注解来配置和映射原生类型、接口和Java的POJO （Plain Old Java Objects,普通老式Java对 象）为数据库中的记录。2.3 MyBatis 历史1. 原是Apach e的一个开源项目iBatis, 2010年6月这个项目由Apache Software Foundation迁移到了 Google Code,随着开发团队转投Google Code旗下，iBatis3.x正式更名为MyBatis，代码于 2013年11月迁移到Github （下载地址见后）。2. iBatis—词来源于"internet”和"abati s啲组合，是一个基于Java的持久层框架。2.4 MyBatis 优势MyBatis是一个半自动化的持久化层框架。对开发人员而言，核心sql还是需要自己优化，sql和 java编码分开，功能边界清晰，一个专注业务、一个专注数据。分析图示如下:  javaBeaMyBatis：半自动，轻量级的框架配置文件Sql与java编用验离；sql是开发人员控制第三部分Mybatis基本应用3.1快速入门MyBatis官网地址：http://www.mybatis.org/mybatis-3/REFERENCE DOCUMENTATIONIntroductionGetting Started Configuration XML Mapper XML Files Dynamic SQL Java APISQL Builder Class LoggingPROJECT DOCUMENTATION Project InformationCl Management Dependencies DependencyInformation DistributionManagementAboutIssue ManagementLicensesMailing ListsIntroductionWhat is MyBatis?MyBatis is a first class persistence framework with support for custom SQL, stored procedures and advanced mappings. MyBatis eliminates almost all of the JDBC code and manual setting of parameters and retrieval of results. MyBatis can use simple XML or Annotations for configuration and map primitives. Map interftices and Java POJOs (Plain Old Java Objects) to database records.Help make this documentation better...If you find this documentation lacking in any way, or missing documentation for a feature, then the best thing to do is learn about it and then write the documentation yourself!Sources of this manual are available in xdoc format at projects Git ♦Fork the repository, update them and send a pull request.You're the best author of this documentation, people like you have to read it!TranslationsUsers can read about MyBatis in following translations:目^English^^Espanol•日本語■简体中文Do you want to read about MyBatis in your own native language? File an issue providing patches with your mother tongue documentation!MyBatis开发步骤:① 添加MyBatis的坐标② 创建user数据表③编写U ser实体类④ 编写映射文件UserMapper.xml⑤ 编写核心文件SqlMapConfig.xml⑥ 编写测试类3.1.2环境搭建                                          1）导入MyBati s的坐标和其他相关坐标<properties><project.build.sourceEncoding>UTF-8</project.build.sourceEncoding><maven.compiler.encoding>UTF-8</maven.compiler.encoding><java.version>1.8</java.version><maven.compiler.source>1.8</maven.compiler.source><maven.compiler.target>1.8</maven.compiler.target></properties><! --mybatis坐标一一><dependency><groupId>org.mybatis</groupId><artifactId>mybatis</artifactId><version>3.4.5</version></dependency><! --mysql驱动坐标--><dependency><groupId>mysql</groupId><artifactId>mysql-connector-java</artifactId><version>5.1.6</version><scope>runtime</scope></dependency><!--单元测试坐标--><dependency><groupId>junit</groupId><artifactId>junit</artifactId><version>4.12</version></dependency>2）创建user数据表 3）编写U ser实体 public class User { private int id;private String username; private String password;//省略get/set方法}4）编写UserMapper映射文件<?xml version=H1.0H encoding=HUTF-8H ?><!DOCTYPE mapperPUBLIC "-//mybatis.org//DTD Mapper 3.0//EN""http://mybatis.org/dtd/mybatis-3-mapper.dtd"><mapper namespace="userMapper"><select id="findAll" resultType="com.lagou.domain.User"> select * from User</select></mapper>5）编写MyBatis核心文件<?xml version="1.0" encoding="UTF-8" ?><!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN""http://mybatis.org/dtd/mybatis-3-config.dtd">〈configuration〉<environments default="development"> <environment id="development"> <transactionManager type="JDBC"/><dataSourcetype="POOLED"><property<property <property <propertyname="driver" value="com.mysql.jdbc.Driver"/> name="url" value="jdbc:mysql:///test"/>name="username" value="root"/>name="password" value="root"/></dataSource></environment></environments><mappers><mapper resource="com/lagou/mapper/UserMapper.xml"/> </mappers></configuration>3.1.3编写测试代码  〃加载核心配置文件Inputstream resourceAsStream =Resources.getResourceAsStream("SqlMapConfig.xml");//获得sqlSession工厂对象SqlSessionFactory sqlSessionFactory = newSqlSessionFactoryBuilder().build(resourceAsStream);//获得sqlSession对象SqlSession sqlSession = sqlSessionFactory.openSession();//执行sql语句List<User> userList = sqlSession.selectList("userMapper.findAll");〃打印结果System.out.println(userList);〃释放资源sqlSession.close();3.1.4 mybati s增删改查操作MyBat is的插入数据操作1) 编写U serMapper映射文件<mapper namespace="userMapper"><insert id="add" parameterType="com.lagou.domain.User">insert into user values(#{id},#{username},#{password})</insert></mapper>2) 编写插入实体U ser的代码InputStream resourceAsStream =Resources.getResourceAsStream("SqlMapConfig.xml");SqlSessionFactory sqlSessionFactory = newSqlSessionFactoryBuilder().build(resourceAsStream);SqlSession sqlSession = sqlSessionFactory.openSession();int insert = sqlSession.insert("userMapper.add", user);System.out.println(insert);//提交事务sqlSession.commit();sqlSession.close();3) 插入操作注意问题•插入语句使用insert标签•在映射文件中使用parameterTyp e属性指定要插入的数据类型•Sql语句中使用#{实体属性名}方式引用实体中的属性值•插入操作使用的API是sqlSession.insert(“命名空间.id”,实体对象)；•插入操作涉及数据库数据变化，所以要使用sqISession对象显示的提交事务，即sqlSession.commit()MyBat is的修改数据操作1) 编写U serMapper映射文件<mapper namespace="userMapper"><update id="update" parameterType="com.lagQu.domain.User">update user set username=#{username},password=#{password} where id=#{id}</update></mapper>2) 编写修改实体U ser的代码Inputstream resourceAsStream =Resources.getResourceAsStream("SqlMapConfig.xml");SqlSessionFactory sqlSessionFactory = newSqlSessionFactoryBuilder().build(resourceAsStream);SqlSession sqlSession = sqlSessionFactory.openSession();int update = sqlSession.update("userMapper.update", user);System.out.println(update);sqlSession.commit();sqlSession.close();3) 修改操作注意问题•修改语句使用updat e标签•修改操作使用的API是sqISession.update(“命名空间.id”,实体对象)；MyBati s的删除数据操作1)编写U serMapper映射文件<mapper namespace="userMapper"><delete id="delete" parameterType="java.lang.Integer">delete from user where id=#{id}</delete></mapper>2）编写删除数据的代码Inputstream resourceAsStream =Resources.getResourceAsStream("SqlMapConfig.xml"); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(resourceAsStream);SqlSession sqlSession = sqlSessionFactory.openSession(); int delete = sqlSession.delete("userMapper.delete",3); System.out.println(delete);sqlSession.commit(); sqlSession.close();3) 删除操作注意问题•删除语句使用delet e标签•Sql语句中使用#｛任意字符串｝方式引用传递的单个参数•删除操作使用的API是sqlSession.delete(“命名空间.id"Qbject);3.1.5入门映射配置文件分析  间盘纟聪軸的SIR3.1.6入门核心配置文件分析MyBatis核心配置文件层级关系• configuration 酉通o properties 属性。settings 设置。typeAliases类型别名。typeHandlers类型处理器。objectFactory 对象工T。plugins 插件。environments■ environment・ transactionManager 事务1管理器.datasource 数据源© databaseldProvider数据库厂商标识。mappers映射器MyBat is常用配置解析1)environment s 标签数据库环境的配置，支持多环境配置  其中，事务管理器(transactionManager)类型有两种：•JDBC：这个配置就是直接使用了JDBC的提交和回滚设置，它依赖于从数据源得到的连接来管理事务作 用域。•MANAGED :这个配置几乎没做什么。它从来不提交或回滚一个连接，而是让容器来管理事务的整个生 命周期(比如JEE应用服务器的上下文)。默认情况下它会关闭连接，然而一些容器并不希望这样，因 此需要将closeConnection属性设置为false来阻止它默认的关闭行为。其中，数据源(dataSource)类型有三种：•UNPOOLED:这个数据源的实现只是每次被请求时打开和关闭连接。•POOLED：这种数据源的实现利用"池啲概念将JDBC连接对象组织起来。•JNDI :这个数据源的实现是为了能在如EJB或应用服务器这类容器中使用，容器可以集中或在外部配 置数据源，然后放置一个JNDI上下文的引用。2)mapper 标签该标签的作用是加载映射的，加载方式有如下几种：•使用相对于类路径的资源引用，例如：•使用完全限定资源定位符(URL),例如：•使用映射器接口实现类的完全限定类名，例如：〈mapper class="org.mybatis.builbu•将包内的映射器接口实现全部注册为映射器，例如：3.1.7 Mybatis 相应 API 介绍SqISession 工厂构建器 SqISessionFactoryBuilder常用API: SqlSessionFactory build(InputStream inputstream)通过加载mybati s的核心文件的输入流的形式构建一个SqISessionFactory对象String resource = "org/mybatis/builder/mybatis-config.xml";Inputstream inputstream = Resources.getResourceAsStream(resource); SqlSessionFactoryBuilder builder = new SqlSessionFactoryBuilder(); SqlSessionFactory factory = builder.build(inputStream);其中，Resources工具类，这个类在org.apache.ibatis.io包中。Resources类帮助你从类路径下、文 件系统或一个web URL中加载资源文件。SqISession 工厂对象 SqISessionFactorySqlSessionFactory有多个个方法创建SqISession实例。常用的有如下两个：  領认开启f事务，但事务不会自动胶，也就意味着需要手动提 交该事务，更新操作数据才会持久化到数据库中参数为是否自动提交，如果设置为true,那么不需要手动提交事务SqISession会话对象SqlSession实例在MyBatis中是非常强大的一个类。在这里你会看到所有执行语句、提交或回滚事务 和获取映射器实例的方法。执行语句的方法主要有：<T> T selectOne(String statement, Object parameter)<E> List<E> selectList(String statement, Object parameter) int insert(String statement, Object parameter) int update(String statement, Object parameter) int delete(String statement, Object parameter)操作事务的方法主要有:void commit() void rollback()3.2 Mybatis 的 D ao 层实现3.2.1传统开发方式 编写U serDao接口public interface UserDao {List<User> findAll() throws IOException;编写U serDaoImp I实现public class UserDaoImpl implements UserDao {public List<User> findAll() throws lOException {Inputstream resourceAsStream =Resources.getResourceAsStream("SqlMapConfig.xml");SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(resourceAsStream);SqlSession sqlSession = sqlSessionFactory.openSession();List<User> userList = sqlSession.selectList("userMapper.findAll"); sqlSession.close();return userList;}}测试传统方式@Testpublic void testTraditionDao() throws IOException {UserDao userDao = new UserDaoImpl();List<User> all = userDao.findAll();System.out.println(all);}3.2.2代理开发方式代理开发方式介绍采用Mybatis的代理开发方式实现DAO层的开发Mapper接口开发方法只需要程序员编写Mapper接口(相当于Dao接口)，由Mybatis框架根据接口 定义创建接口的动态代理对象，代理对象的方法体同上边Da。接口实现类方法。Mapper接口开发需要遵循以下规范：1) Mapper.xml文件中的namespace与mapper接口的全限定名相同2) Mapper接口方法名和Mapper.xml中定义的每个statement的id相同3) Mapper接口方法的输入参数类型和mapper.xml中定义的每个sq啲parameterType的类型相同4) Mapper接口方法的输出参数类型和mapper.xml中定义的每个sq啲resultType的类型相同编写 U serMapper 接口  测试代理方式@Testpublic void testProxyDao() throws lOException {Inputstream resourceAsStream =Resources.getResourceAsStream("SqlMapConfig.xml");SqlSessionFactory sqlSessionFactory = newSqlSessionFactoryBuilder().build(resourceAsStream);SqlSession sqlSession = sqlSessionFactory.openSession();//获得MyBatis框架生成的UserMapper接口的实现类UserMapper userMapper = sqlSession.getMapper(UserMapper.class);User user = userMapper.findById(1);System.out.println(user); sqlSession.close();}第四部分Mybatis配置文件深入4.1 SqlMapConfig.xml4.1.1 MyBatis核心配置文件层级关系• configuration 酉彊。properties 属性。settings 设置。typeAliases类型别名。typeHandlers类型处理器。objectFactory 对象工T。plugins 插件。environments■ environment■ transactionManager 事务管理器.datasource 数据源o databaseldProvider数据库厂商标识。mappers映射器4.1.2 MyBati s常用配置解析1) environment s 标签  其中，事务管理器(transactionManager)类型有两种：•JDBC：这个配置就是直接使用了JDBC的提交和回滚设置，它依赖于从数据源得到的连接来管理事务作 用域。•MANAGED :这个配置几乎没做什么。它从来不提交或回滚一个连接，而是让容器来管理事务的整个生 命周期(比如JEE应用服务器的上下文)。默认情况下它会关闭连接，然而一些容器并不希望这样，因 此需要将closeConnection属性设置为false来阻止它默认的关闭行为。其中，数据源(dataSource)类型有三种：•UNPOOLED:这个数据源的实现只是每次被请求时打开和关闭连接。•POOLED：这种数据源的实现利用"池啲概念将JDBC连接对象组织起来。•JNDI :这个数据源的实现是为了能在如EJB或应用服务器这类容器中使用，容器可以集中或在外部配 置数据源，然后放置一个JNDI上下文的引用。2) mapper 标签该标签的作用是加载映射的，加载方式有如下几种：•使用相对于类路径的资源引用，例如：•使用完全限定资源定位符(URL),例如：•使用映射器接口实现类的完全限定类名，例如：•将包内的映射器接口实现全部注册为映射器，例如：3) Properties 标签习惯将数据源的配置信息单独抽取成一个properties文件，该标签可以加载额外配置的properties文件<environment id= development > <transactionManager type=" <dataSource type="POOLED"> "driver	~	.driver}'/>"url" valuer"${j "username" value="${jdbc.username}"/> "password" value="$(jdbc.password}"/></environments>    4.2 mapper.xml4.2.1动态sql语句 动态sql语句概述Mybatis的映射文件中，前面我们的SQL都是比较简单的，有些时候业务逻辑复杂时，我们的SQL是 动态变化的，此时在前面的学习中我们的SQL就不能满足要求了。参考的官方文档，描述如下：Dynamic SQLOne of tfie most poweiful features of MyCatis has always been its Dynamic SQL capabilities if you have any experience with JDBC or any simHar framework, you unaerstand how painful it is to condidonaity concatenate strings of SQL together, making sure not to forget spaces or to om« a comma at the eno of a list of columns Dynamic SQL can be downright painTui to deal withwniie working with Dynamic SQL will never De a party, MyBatis certaint/ improves the situation with a powerful Dynarmc SQL language that can be used witrun any mapped SQL statement.The Dynamic SQL elements should be familiar to anyone who has used JSTL or any similar XML based text processors. In previous versions of MyBatis. there were a lot of elements to know and understand. MyBatis 3 greatly improves upon ttiis. and now Mere are less than half of those elements to wort< wrtfi. MyBatis employs powerful OGNL based expressions to eliminate most or the other elements:• if• choose (when, otherwise)• trim (wtiere. set)• foreach动态SQL之我们根据实体类的不同取值，使用不同的SQL语句来进行查询。比如在id如果不为空时可以根据id查 询，如果username不同空时还要加入用户名作为条件。这种情况在我们的多条件组合查询中经常会碰 到。<select id=HfindByConditionH parameterType="user" resultType=HuserH>select * from User<where><if test="id!=0">and id=#{id}</if><if test="username!=null">and username=#{username}</if></where></select>当查询条件id和username都存在时，控制台打印的sql语句如下：//获得MyBatis框架生成的UserMapper接口的实现类UserMapper userMapper = sqlSession.getMapper(UserMapper.class);User condition = new User();condition.setId(1);condition.setUsername("lucy");User user = userMapper.findByCondition(condition);-Created connection 586084331.-Setting autocommit t。 false on JDBC Connection [com.mycql・jdbc -==> Preparing: [select * from User WHERE id=? and usermarne=?[ . ==> Parameters: l(Integer)lucy(String)-<== Total: 1当查询条件只有id存在时，控制台打印的sql语句如下：//获得MyBatis框架生成的UserMapper接口的实现类UserMapper userMapper = sqlSession.getMapper(UserMapper.class);User condition = new User();condition.setId(1);User user = userMapper.findByCondition(condition);-Setting autocomipit to false on JDBC Connection-==>	Preparing:	select * from	User WHERE id=?-==>	Parameters:	l(Integer)-<==	Total:	1动态SQL之循环执行sql的拼接操作，例如：SELECT * FROM USER WHERE id IN (1,2,5)。<select id="findByIds" parameterType="list" resultType="user"> select * from User<where> vforeach collection="array" open="id in(" close=")" item="id separator=",">#{id}</foreach></where></select>测试代码片段如下：//获得MyBatis框架生成的UserMapper接口的实现类UserMapper userMapper = sqlSession.getMapper(UserMapper.class); int[] ids = new int[]{2,5};List<User> userList = userMapper.findByIds(ids);System.out.println(userList);11:21:02^237 DEBUG findBylds:159 - ==> Preparing: [select * from User WHERE id in( ? , ? )|11:21:02^262 DEBUG findBylds:159 - ==> Parameters: 2(Integer), 5(Integer)?1:21:。2・280 DEBUG findBvIds:159 ・ <==	2lTUsep{id=2. use广name='tom‘・ password= ' 123' } . User{id=5. username=' lucylucy ' . password^ ' 123' }llforeach标签的属性含义如下：标签用于遍历集合，它的属性：•collection :代表要遍历的集合元素，注意编写时不要写#{}•open:代表语句的开始部分•close：代表结束部分•item :代表遍历集合的每个元素，生成的变量名•sperator：代表分隔符SQL片段抽取Sql中可将重复的sql提取出来，使用时用include引用即可，最终达到sql重用的目的<! 一抽取sql片段简化编写--><sql id=HselectUserH select * from User</sql><select id=HfindByIdH parameterType="int" resultType=HuserH><include refid="selectUser"></include> where id=#{id}</select><select id="findByIds" parameterType="list" resultType="user"><include refid="selectUser"></include><where><foreach collection="array" open="id in(" close=")" item="id"separator=",">#{id}</foreach></where></select>第五部分Mybatis复杂映射开发5.1 —对一查询—对一查询的模型 MapperScannerConfigurer用户表和订单表的关系为，一个用户有多个订单，一个订单只从属于一个用户一对一查询的需求：查询一个订单，与此同时查询出该订单所属的用户信息orders覺 id:intordertime: varchar(255)— total: doubleuid: int一对一查询的语句 对应的sql语句：select * from orders o,user u where o.uid=u.id;查询的结果如下:信息結果1状态 idordertimetotaluid	id1usernamepasswordbirthday► 1 2018-12-12300011 lucy1231539751863457  2 2019-12-12400011 lucy1231539751863457  3 2020-12-12500022 tom1231539751863457创建Order和User实体 public class Order {private int id;private Date ordertime; private double total;〃代表当前订单从属于哪一个客户 private User user;}public class User {private int id;private String username; private String password; private Date birthday;}创建 OrderMapper 接口public interface OrderMapper { List<Order> findAll();}配置 OrderMapper.xml<mapper namespace="com.lagou.mapper.OrderMapper"><resultMap id="orderMap" type="com.lagou.domain.Order"><result column="uid" property="user.id"></result><result column="username" property="user.username"></result><result column="password" property="user.password"></result><result column="birthday" property="user.birthday"></result> </resultMap><select id="findAll" resultMap="orderMap">select * from orders o,user u where o.uid=u.id</select></mapper>其中还可以配置如下：<resultMap id="orderMap" type="com.lagou.domain.Order"><result property="id" column="id"></result><result property="ordertime" column="ordertime"></result><result property="total" column="total"></result>〈association property="user" javaType="com.lagou.domain.User"><result column="uid" property="id"></result><result column="username" property="username"></result><result column="password" property="password"></result><result column="birthday" property="birthday"></result> </association></resultMap>测试结果OrderMapper mapper = sqlSession.getMapper(OrderMapper.class);List<Order> all = mapper.findAll();for(Order order : all){System.out.println(order);}     5.2 —对多查询一对多查询的模型用户表和订单表的关系为，一个用户有多个订单，一个订单只从属于一个用户一对多查询的需求：查询所有用户，与此同时查询出该用户具有的订单orders够 id:intordertime: varchar(255) * total: doubleuid: int一对多查询的语句对应的sql语句：select *,o.id oid from user u left join orders o on u.id=o.uid;查询的结果如下：信息 结果1 祗况 状志 idusernamepasswordbirthdayid1ordertimetotaluid	oid►1lucy1232018-12-1212018-12-12300011 1lucy1232018-12-1222019-12-12400012 2tom1232018-12-1232020-12-12500023 修改U ser实体public class Order {private int id;private Date ordertime; private double total;〃代表当前订单从属于哪一个客户 private User user;}public class User {private int id;private String username; private String password; private Date birthday;//代表当前用户具备哪些订单 private List<Order> orderList;}创建 UserMapper 接口public interface UserMapper { List<User> findAll();}配置 UserMapper.xml<mapper namespace="com.lagou.mapper.UserMapper"><resultMap id="userMap" type="com.lagou.domain.User"><result column="id" property="id"></result><result column="username" property="username"></result><result column="password" property="password"></result><result column="birthday" property="birthday"></result>  <result column="oid" property="id"></result> <result column="ordertime" property="ordertime"></result> <result column="total" property="total"></result></collection></resultMap><select id="findAll" resultMap="userMap">select *,o.id oid from user u left join orders o on u.id=o.uid </select></mapper>测试结果UserMapper mapper = sqlSession.getMapper(UserMapper.class);List<User> all = mapper.findAll(); for(User user : all){System.out.println(user.getUsername());List<Order> orderList = user.getOrderList(); for(Order order : orderList){System.out.println(order);}System.out.println("	");}  haohao10:02:27,868 DEBUG DdbcTransaction:54 - Resetting autocommit to true on10:02:27,869 DEBUG JdbcTransaction:54 - Closing JDBC Connection [com.mysql.jdbc.3DBC4Connection^289dlc02] 10:02:27,869 DEBUG PooledDataSource:54 - Returned connection 681384962 to pool.5.3多对多查询多对多查询的模型用户表和角色表的关系为，一个用户有多个角色，一个角色被多个用户使用多对多查询的需求：查询用户同时查询出该用户的所有角色 对应的sql语句：select u.,r.,r.id rid from user u left join user_role ur on u.id=ur.user_id inner join role r on ur.role_id=r.id;查询的结果如下:信息结果1	概况状态 idusernamepasswordbirthdayid1rolename► 1 lucy1232018-12-121CEO  1 lucy1232018-12-122CFO  2 tom1232018-12-122CFO  2 tom1232018-12-123COO 创建Role实体，修改User实体public class User {private int id;private String username;private String password;private Date birthday;//代表当前用户具备哪些订单 private List<Order> orderList; //代表当前用户具备哪些角色 private List<Role> roleList;}public class Role {private int id; private String rolename;}添加u serMapper接口方法List<User> findAllUserAndRole();配置 UserMapper.xml @Insert :实现新增@Update :实现更新@Delete：实现删除@Select：实现查询@Result :实现结果集封装@Results:可以与@Result 一起使用，封装多个结果集@One：实现一对一结果集封装@Many :实现一对多结果集封装6.2 MyBatis的增删改查我们完成简单的user表的增删改查的操作private UserMapper userMapper;@Beforepublic void before() throws lOException {Inputstream resourceAsStream =Resources.getResourceAsStream("SqlMapConfig.xml");SqlSessionFactory sqlSessionFactory = newSqlSessionFactoryBuilder().build(resourceAsStream);SqlSession sqlSession = sqlSessionFactory.openSession(true); userMapper = sqlSession.getMapper(UserMapper.class);}@Testpublic void testAdd() {User user = new User();user. setUsername ("测试数据");user.setPassword("123");user.setBirthday(new Date());userMapper.add(user);}@Testpublic void testUpdate() throws IOException {User user = new User();user.setId(16);user. setUsername ("测试数据修改");user.setPassword("abc");user.setBirthday(new Date());userMapper.update(user);}@Testpublic void testDelete() throws IOException {userMapper.delete(16);}@Testpublic void testFindById() throws lOException { User user = userMapper.findById(1); System.out.println(user);}@Testpublic void testFindAll() throws IOException { List<User> all = userMapper.findAll(); for(User user : all){System.out.println(user);}}修改MyBati s的核心配置文件，我们使用了注解替代的映射文件，所以我们只需要加载使用了注解的 Mapper接口即可<mappers><!--扫描使用注解的类--><mapper class="com.lagou.mapper.UserMapper"></mapper> </mappers>或者指定扫描包含映射关系的接口所在的包也可以<mappers><!--扫描使用注解的类所在的包--><package name="com.lagou.mapper"></package> </mappers>6.3 MyBatis的注解实现复杂映射开发实现复杂关系映射之前我们可以在映射文件中通过配置来实现，使用注解开发后，我们可以使用 @Results注解，@Result注解，@One注解，@Many注解组合完成复杂关系的配置  6.4 一对一查询（注解）  一对一查询的模型用户表和订单表的关系为，一个用户有多个订单，一个订单只从属于一个用户一对一查询的需求：查询一个订单，与此同时查询出该订单所属的用户orders寸 id:intordertime: varchar(255) * total: doubleuid: int一对一查询的语句对应的sql语句：select * from orders;select * from user where id=查询出订单的 uid;查询的结果如下:信息結果1	柵况状态 idordertimetotaluid	id1usernamepasswordbirthday► 1 2018-12-12300011 lucy1231539751863457  2 2019-12-12400011 lucy1231539751863457  3 2020-12-12500022 tom1231539751863457创建Order和User实体 public class Order {private int id;private Date ordertime; private double total;〃代表当前订单从属于哪一个客户 private User user;}public class User {private int id;private String username; private String password; private Date birthday;创建 OrderMapper 接口public interface OrderMapper {List<Order> findAll();}使用注解配置Mapperpublic interface OrderMapper {@Select("select * from orders")@Results({@Result(id=true,property = "id",column = "id"), @Result(property = "ordertime",column = "ordertime"), @Result(property = "total",column = "total"), @Result(property = "user",column = "uid", javaType = User.class, one = @One(select ="com.lagou.mapper.UserMapper.findById"))})List<Order> findAll();}public interface UserMapper {@Select("select * from user where id=#{id}")User findById(int id);}测试结果@Test public void testSelectOrderAndUser() {List<Order> all = orderMapper.findAll(); for(Order order : all){System.out.println(order);}}      6.5 一对多查询（注解）  一对多查询的模型用户表和订单表的关系为，一个用户有多个订单，一个订单只从属于一个用户 一对多查询的需求：查询所有用户，与此同时查询出每个用户具有的订单orders寸 id:intordertime: varchar(255) * total: doubleuid: int一对多查询的语句 对应的sql语句:select * from user;select * from orders where uid=查询出用户的 id;查询的结果如下:信息结果1概况状态      idusernamepasswordbirthdayid1ordertimetotaluid	oid ►1 lucy1232018-12-1212018-12-12300011 1 lucy1232018-12-1222019-12-12400012 2 tom1232018-12-1232020-12-12500023 修改User实体public class Order {private int id;private Date ordertime;private double total;〃代表当前订单从属于哪一个客户 private User user;}public class User {private int id;private String username;private String password; private Date birthday;//代表当前用户具备哪些订单 private List<Order> orderList;创建 UserMapper 接口List<User> findAllUserAndOrder();使用注解配置Mapperpublic interface UserMapper {@Select("select * from user")@Results({@Result(id = true,property = "id",column = "id"), @Result(property = "username",column = "username"), @Result(property = "password",column = "password"), @Result(property = "birthday",column = "birthday"), @Result(property = "orderList",column = "id", javaType = List.class, many = @Many(select ="com.lagou.mapper.OrderMapper.findByUid"))})List<User> findAllUserAndOrder();}public interface OrderMapper {@Select("select * from orders where uid=#{uid}") List<Order> findByUid(int uid);}测试结果List<User> all = userMapper.findAllUserAndOrder(); for(User user : all){System.out.println(user.getUsername());List<Order> orderList = user.getOrderList(); for(Order order : orderList){System.out.println(order);}System.out.println("	");} 6.6多对多查询（注解）多对多查询的模型用户表和角色表的关系为，一个用户有多个角色，一个角色被多个用户使用多对多查询的需求：查询用户同时查询出该用户的所有角色user  user_role r	role	1username: varchar(50)-H_ei-导 user_id:inthe—h-早 id: intpassword: varchar(50) ® rolejd: int rolename: varchar(255)birthday: varchar(50) 多对多查询的语句 对应的sql语句:select * from user;select * from role r,user_role ur where r.id=ur.role_id and ur.user_id=用户的id查询的结果如下:信息结果1	槪况状态 idusernamepasswordbirthdayid1rolename► 1 lucy1232018-12-121CEO  1 lucy1232018-12-122CFO  2 tom1232018-12-122CFO  2 tom1232018-12-123COO 创建Role实体，修改User实体public class User {private int id;private String username; private String password;private Date birthday;  //代表当前用户具备哪些订单private List<Order> orderList;//代表当前用户具备哪些角色private List<Role> roleList;public class Role {private int id; private String rolename;}添加u serMapper接口方法List<User> findAllUserAndRole();使用注解配置Mapperpublic interface UserMapper { @Select("select * from user") @Results({@Result(id = true,property = "id",column = "id"), @Result(property = "username",column = "username"), @Result(property = "password",column = "password"), @Result(property = "birthday",column = "birthday"), @Result(property = "roleList",column = "id", javaType = List.class, many = @Many(select ="com.lagou.mapper.RoleMapper.findByUid"))})List<User> findAllUserAndRole();}public interface RoleMapper {@Select("select * from role r,user_role ur where r.id=ur.role_id and ur.user_id=#{uid}")List<Role> findByUid(int uid);}测试结果  UserMapper mapper = sqlSession.getMapper(UserMapper.class);List<User> all = mapper.findAllUserAndRole(); for(User user : all){System.out.println(user.getUsername());List<Role> roleList = user.getRoleList();for(Role role : roleList){System.out.println(role);}System.out.println("	");}  tomRo】e{id=2, rolename='CFO'}Role{id=3, rolename='COO,}第七部分Mybatis缓存缓存就是内存中的数据，常常来自对数据库查询结果的保存，使用缓存，我们可以避免频繁的与数据库 进行交互，进而提高响应速度mybatis也提供了对缓存的支持，分为一级缓存和二级缓存，可以通过下图来理解： sqlSessionl一级缓存 sqlSession2一级缓存 sqlSession3一级缓存 Mapper(namespace)二级缓存        ① 、一级缓存是s qlSession级别的缓存。在操作数据库时需要构造sqISession对象，在对象中有一个数 据结构（HashMap）用于存储缓存数据。不同的sqISession之间的缓存数据区域（HashMap）是互相 不影响的。② 、二级缓存是mapper级别的缓存，多个SqISession去操作同一个Mapper的sql语句，多个 SqISession可以共用二级缓存，二级缓存是跨SqISession的7.1 一级缓存①、我们在一个sqISession中，对User表根据id进行两次查询，查看他们发出s ql语句的情况。@Testpublic void testl(){//根据 sqlSessionFactory 产生 sessionSqISession sqlSession = sessionFactory.openSession();UserMapper userMapper = sqlSession.getMapper(UserMapper.class);〃第一次查询，发出sql语句，并将查询的结果放入缓存中User ul = userMapper.selectUserByUserId(l);System.out.println(ul);//第二次查询，由于是同一个sqlSession，会在缓存中查找查询结果//如果有，则直接从缓存中取出来，不和数据库进行交互User u2 = userMapper.selectUserByUserId(1);System.out.println(u2);sqlSession.close();}查看控制台打印情况:  ②、同样是对user表进行两次查询，只不过两次查询之间进行了一次update操作。@Testpublic void test2(){//根据 sqlSessionFactory 产生 sessionSqlSession sqlSession = sessionFactory.openSession();UserMapper userMapper = sqlSession.getMapper(UserMapper.class); 〃第一次查询，发出sql语句，并将查询的结果放入缓存中User u1 = userMapper.selectUserByUserId( 1 );System.out.println(u1);//第二步进行了一次更新操作，sqlSession.commit()u1. setSex ("女");userMapper.updateUserByUserId(u1);sqlSession.commit();//第二次查询，由于是同一个sqlSession.commit(),会清空缓存信息 //则此次查询也会发出sql语句User u2 = userMapper.selectUserByUserId(1);System.out.println(u2);sqlSession.close();}控制台打印情况:OOO 卩c~ing Ccnnacti cn [ccm.mYsql . jdbc .	(I==> I Preparing, select * from user where id=? | (Log4jImpl.java:4€ ==> Parameter^? 1(Integer) (Log4jImpl・java:4 6)sex=男]第一次做发出冲语句	史新和ooo Using Connection 【com.invsql.jdbc.JDBC4Connection&6?5fb960] (I ==> Preparing:[update user set username=? where id=? | (Log4jImpl ==> Parameters: tom (String) , 1 (Integer)	(Log4 j TmpJ.. java: 46)Committing JDBC Connection [com.mysql.jdbc.JDBC4Connection@635fb9€ ooo Using Connection [com.mysql.jdbc.JDBC4Connection@635fb960] (I ==> I Preparing: select ★ from user where id=? |(Log4jImp].java:4C ==> ParBmeters: 1 (Integer) (匹g4 j Impl. ： java : 46)sex=男]由「逬行了史新操作・缓O治除版第•「次行而继续发出sqli”j    ③ 、总结1、第一次发起查询用户id为1的用户信息，先去找缓存中是否有id为1的用户信息，如果没有，从 数据库查询用户信息。得到用户信息，将用户信息存储到一级缓存中。2、	如果中间sqISession去执行commit操作（执行插入、更新、删除），则会清空SqISession中的 一级缓存，这样做的目的为了让缓存中存储的是最新的信息，避免脏读。3、	第二次发起查询用户id为1的用户信息，先去找缓存中是否有id为1的用户信息，缓存中有，直 接从缓存中获取用户信息  一级缓存原理探究与源码分析一级缓存到底是什么？一级缓存什么时候被创建、一级缓存的工作流程是怎样的？相信你现在应该会有 这几个疑问，那么我们本节就来研究一下一级缓存的本质 大家可以这样想，上面我们一直提到一级缓存，那么提到一级缓存就绕不开SqISession,所以索性我们 就直接从SqlSession，看看有没有创建缓存或者与缓存有关的属性或者方法  SqISession.javaInherited members (3€O) Anonymous Classes (9€l) Lambdas (3€L)	令蔺 SqISessionm 七 clearCache(): void1(1 close(): void• * commitO： voidi|i 七 commit(boolean): voideE delete(String): int• % delete(String, Object): intmi 七 flushStatements(): List<BatchResult> mi 七 getConfiguration(): Configuration imi % getConnection(): Connection imE getMapper(Class<T>): T m 七 insert(String): intmm insert(String, Object): int i|» 七 rollback(): void'mi 七 rollback(boolean): voidm 七 select(String, Object, ResultHandler): voidmE select(String, Object, RowBounds, ResultHandler): void mi 七 select(String, ResultHandler): voidm 七 selectCursor(String): Cursor<T>m % selectCursor(String, Object): Cursor<T>mi selectCursor(String, Object, RowBounds): Cursor<T> 關七 selectList(String): List<E>mm selectList(String, Object): List<E>mi k selectList(String, Object, RowBounds): List<E>mi h selectMap(String, Object, String): Map<K, V>mi 七 selectMap(String, Object, String, RowBounds): Map<K, V> ee selectMap(String, String): Map<K, V>rnE selectOne(String): T如 selectOne(String, Object): T% update(String): intmi Ta update(String, Object): int调研了一圈，发现上述所有方法中，好像只有clearCache()和缓存沾点关系，那么就直接从这个方 法入手吧，分析源码时，我们要看它(此类)是谁，它的父类和子类分别又是谁，对如上关系了解了，你才 会对这个类有更深的认识，分析了一圈，你可能会得到如下这个流程图  再深入分析，流程走到Perpetualcache中的clear()方法之后，会调用其cache.clear()方法，那 么这个cache是什么东西呢？点进去发现，cache其实就是private Map cache = new HashMap()；也就是一个Map,所以说cache.clear()其实就是map.clear()，也就是说，缓存其实就是 本地存放的一个map对象，每一个SqISession都会存放一个map对象的引用，那么这个cache是何 时创建的呢？ 你觉得最有可能创建缓存的地方是哪里呢？我觉得是Executor，为什么这么认为？因为Executor是 执行器，用来执行SQL请求，而且清除缓存的方法也在Executor中执行，所以很可能缓存的创建也很 有可能在Executor中，看了一圈发现Executor中有一个createCacheKey方法，这个方法很像是创 建缓存的方法啊，跟进去看看，你发现createCacheKey方法是由BaseExecutor执行的，代码如下CacheKey cacheKey = new CacheKey(); //MappedStatement 的 id// id就是Sql语句的所在位置包名+类名+ SQL名称 cacheKey.update(ms.getId());// offset 就是 0 cacheKey.update(rowBounds.getOffset());// limit 就是 Integer.MAXVALUE cacheKey.update(rowBounds.getLimit());//具体的SQL语句cacheKey.update(boundSql.getSql());//后面是update 了 sql中带的参数 cacheKey.update(value);if (configuration.getEnvironment() != null) {// issue #176cacheKey.update(configuration.getEnvironment().getId()); }创建缓存key会经过一系列的update方法，叩date方法由一个CacheKey这个对象来执行的，这个 update方法最终由updateList的list来把五个值存进去，对照上面的代码和下面的图示，你应该能 理解这五个值都是什么了▼ cacheKey = (CacheKey@1613) "1175668460:2347460:com.mybatis.dao.Dept'f multiplier = 37f hashcode = 1175668460 f checksum = 2347460f count = 6▼ f updateList = (ArrayList@1687} size = 6► 20 = "com.mybatis.dao.DeptDao.findByDeptNo"► S 1 = {lnteger@1690} 0► = 2 = (lnteger@1691} 2147483647► = 3 = "select * from dept\n \n where deptno = ?"► s 4 = (lnteger@1605} 1► 2 5 = "development"这里需要注意一下最后一个值，configuration.getEnvironment().getId()这是什么，这其实就是 定义在mybatis-config.xml中的标签，见如下。〈environments default="development"> <environment id="development"> <transactionManager type="JDBC"/><dataSource type="POOLED"〉<property name="driver" value="${jdbc.driver}"/><property name="url" value="${jdbc.url}"/><property name="username" value="${jdbc.username}"/><property name="password" value="${jdbc.password}"/> </dataSource></environment></environments>那么我们回归正题，那么创建完缓存之后该用在何处呢？总不会凭空创建一个缓存不使用吧？绝对不会 的，经过我们对一级缓存的探究之后，我们发现一级缓存更多是用于查询操作，毕竟一级缓存也叫做查 询缓存吧，为什么叫查询缓存我们一会儿说。我们先来看一下这个缓存到底用在哪了，我们跟踪到 query方法如下：^Overridepublic <E> List<E> query(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler) throws SQLException {BoundSql boundSql = ms.getBoundSql(parameter);//创建缓存CacheKey key = createCacheKey(ms, parameter, rowBounds, boundSql);return query(ms, parameter, rowBounds, resultHandler, key, boundSql);}@SuppressWarnings("unchecked")^Overridepublic <E> List<E> query(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql) throws SQLException {list = resultHandler == null ? (List<E>) localCache.getObject(key) : null; if (list != null) {//这个主要是处理存储过程用的。handleLocallyCachedOutputParameters(ms, key, parameter, boundSql);} else {list = queryFromDatabase(ms, parameter, rowBounds, resultHandler, key, boundSql);}}// queryFromDatabase 方法private <E> List<E> queryFromDatabase(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql) throws SQLException {List<E> list;localCache.putObject(key, EXECUTION_PLACEHOLDER);try {list = doQuery(ms, parameter, rowBounds, resultHandler, boundSql);} finally { localCache.removeObject(key);}localCache.putObject(key, list);if (ms.getStatementType() == StatementType.CALLABLE) {localOutputParameterCache.putObject(key, parameter);}return list;}如果查不到的话，就从数据库查，在queryFromDatabase中，会对localcache进行写入。 localcache对象的put方法最终交给Map进行存放private Map<Object, Object> cache = new HashMap<Object, Object>();@Overridepublic void putObject(Object key, Object value) { cache.put(key, value);}7.2二级缓存二级缓存的原理和一级缓存原理一样，第一次查询，会将数据放入缓存中，然后第二次查询则会直接去 缓存中取。但是一级缓存是基于sqlSession的，而二级缓存是基于mapper文件的namespace的，也 就是说多个sqlSession可以共享一个mapper中的二级缓存区域，并且如果两个mapper的namespace 相同，即使是两个mapper,那么这两个mapper中执行sql查询到的数据也将存在相同的二级缓存区域 中  如何使用二级缓存: ①、开启二级缓存和一级缓存默认开启不一样，二级缓存需要我们手动开启首先在全局配置文件sqlMapConfig.xml文件中加入如下代码:<!--开启二级缓存--><settings><setting name="cacheEnabled" value="true"/></settings〉其次在UserMapper.xml文件中开启缓存<!--开启二级缓存--><cache></cache>我们可以看到mapper.xml文件中就这么一个空标签，其实这里可以配置,PerpetualCach e这个类是 mybatis默认实现缓存功能的类。我们不写type就使用mybatis默认的缓存，也可以去实现Cache接口 来自定义缓存。  开启了二级缓存后，还需要将要缓存的poj。实现Serializable接口，为了将缓存数据取出执行反序列化操 作，因为二级缓存数据存储介质多种多样，不一定只存在内存中，有可能存在硬盘中，如果我们要再取 这个缓存的话，就需要反序列化了。所以mybati s中的poj。都去实现Serializabl e接口③、测试一、测试二级缓存和sqISession无关@Testpublic' 'void' 'testTwoCache(){//根据 sqlSessionFactory 产生 sessionSqlSession sqlSession1 = sessionFactory.openSession();SqlSession sqlSession2 = sessionFactory.openSession();UserMapper userMapper1 = sqlSession1.getMapper(UserMapper. class ); UserMapper userMapper2 = sqlSession2.getMapper(UserMapper. class ); 〃第一次查询，发出sql语句，并将查询的结果放入缓存中 User u1 = userMapper1.selectUserByUserId(1);System.out.println(u1);sqlSession1.close(); //第一次查询完后关闭 sqlSession〃第二次查询，即使sqlSession1已经关闭了，这次查询依然不发出sql语句 User u2 = userMapper2.selectUserByUserId(1);System.out.println(u2); sqlSession2.close();可以看出上面两个不同的sqlSession,第一个关闭了，第二次查询依然不发出sql查询语句二、测试执行commit()操作，二级缓存数据清空@Testpublic' 'void' 'testTwoCache(){//根据 sqlSessionFactory 产生 sessionsessionFactory.openSession();sessionFactory.openSession();SqlSession sqlSession3 = sessionFactory.openSession();String statement = "com.lagou.pojo.UserMapper.selectUserByUserld"UserMapper userMapper1 = sqlSession1.getMapper(UserMapper.UserMapper userMapper2 = sqlSession2.getMapper(UserMapper.UserMapper userMapper3 = sqlSession2.getMapper(UserMapper. 〃第一次查询，发出sql语句，并将查询的结果放入缓存中User u1 = userMapperl.selectUserByUserId( 1	);System.out.println(u1);sqlSessionl .close(); //第一次查询完后关闭sqlSession//执行更新操作，commit()u1.setUsername( "aaa" );userMapper3.updateUserByUserId(u1); sqlSession3.commit();〃第二次查询，由于上次更新操作，缓存数据已经清空(防止数据脏读)，这里必须再次发出sql语User u2 = userMapper2.selectUserByUserId( 1	);System.out.println(u2);sqlSession2.close();查看控制台情况:     ④、useCache和flushCachemybatis中还可以配置userCache和flushCache等配置项，userCache是用来设置是否禁用二级缓 存的，在statement中设置useCache=false可以禁用当前select语句的二级缓存，即每次查询都会发出 sql去查询，默认情况是true,即该sql使用二级缓存<select id=HselectUserByUserIdH useCache=HfalseH resultType="com.lagou.pojo.User" parameterType="int"> select * from user where id=#{id}</select>这种情况是针对每次查询都需要最新的数据sql,要设置成useCache=false，禁用二级缓存，直接从数 据库中获取。在mapper的同一个namespace中，如果有其它insert、update、delete操作数据后需要刷新缓 存，如果不执行刷新缓存会出现脏读。设置statement配置中的flushCache="true”属性，默认情况下为true,即刷新缓存，如果改成false则 不会刷新。使用缓存时如果手动修改数据库表中的查询数据会出现脏读。<select id="selectUserByUserId" flushCache="true" useCache="false"resultType="com.lagou.pojo.User" parameterType="int">select * from user where id=#{id} </select>一般下执行完commit操作都需要刷新缓存，flushCache=true表示刷新缓存，这样可以避免数据库脏 读。所以我们不用设置，默认即可7.3二级缓存整合redis上面我们介绍了 mybatis自带的二级缓存，但是这个缓存是单服务器工作，无法实现分布式缓存。 那么什么是分布式缓存呢？假设现在有两个服务器1和2,用户访问的时候访问了 1服务器，查询后的缓 存就会放在1服务器上，假设现在有个用户访问的是2服务器，那么他在2服务器上就无法获取刚刚那个 缓存，如下图所示：  为了解决这个问题，就得找一个分布式的缓存，专门用来存储缓存数据的，这样不同的服务器要缓存数 据都往它那里存，取缓存数据也从它那里取，如下图所示：  如上图所示，在几个不同的服务器之间，我们使用第三方缓存框架，将缓存都放在这个第三方框架中, 然后无论有多少台服务器，我们都能从缓存中获取数据。这里我们介绍mybatis与redis的整合。刚刚提到过，mybatis提供了一个eache接口，如果要实现自己的缓存逻辑，实现cache接口开发即可。 mybati s本身默认实现了一个，但是这个缓存的实现无法实现分布式缓存，所以我们要自己来实现。redis分布式缓存就可以，mybatis提供了一个针对cache接口的redis实现类，该类存在mybatis-redis包 中实现：1. pom文件<dependency><groupId>org.mybatis.caches</groupId><artifactId>mybatis-redis</artifactId><version>1.0.0-beta2</version></dependency>2. 配置文件Mapper.xml<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN""http://mybatis.org/dtd/mybatis-3-mapper.dtd"><mapper namespace="com.lagou.mapper.IUserMapper"><cache type="org.mybatis.caches.redis.RedisCache" /><select id="findAll" resultType="com.lagou.pojo.User" useCache="true"> select * from user</select>3. redis.propertiesredis.host=localhostredis.port=6379redis.connectionTimeout=5000redis.password=redis.database=04. 测试@Testpublic void SecondLevelCache(){SqlSession sqlSession1 = sqlSessionFactory.openSession();SqlSession sqlSession2 = sqlSessionFactory.openSession();SqlSession sqlSession3 = sqlSessionFactory.openSession();IUserMapper mapper1 = sqlSession1.getMapper(IUserMapper.class);lUserMapper mapper2 = sqlSession2.getMapper(lUserMapper.class);lUserMapper mapper3 = sqlSession3.getMapper(lUserMapper.class);User user1 = mapper1.findUserById(1);sqlSession1.close(); //清空一级缓存User user = new User();user.setId(1);user.setUsername("lisi");mapper3.updateUser(user);sqlSession3.commit();User user2 = mapper2.findUserById(1);System.out.println(user1==user2);}源码分析：RedisCache和大家普遍实现Mybatis的缓存方案大同小异，无非是实现Cache接口，并使用jedis操作缓 存；不过该项目在设计细节上有一些区别；public final class RedisCache implements Cache {public RedisCache(final String id) {if (id == null) {throw new IllegalArgumentException("Cache instances require an ID");}this.id = id;RedisConfig redisConfig =RedisConfigurationBuilder.getInstance().parseConfiguration();pool = new JedisPool(redisConfig, redisConfig.getHost(), redisConfig.getPort(),redisConfig.getConnectionTimeout(), redisConfig.getSoTimeout(), redisConfig.getPassword(), redisConfig.getDatabase(), redisConfig.getClientName());}RedisCache在mybatis启动的时候，由MyBatis的CacheBuilder创建，创建的方式很简单，就是调用 RedisCache的带有String参数的构造方法，即RedisCache(String id)；而在RedisCache的构造方法中， 调用了 RedisConfigu rationBuilder 来创建 RedisConfig 对象，并使用 RedisConfig 来创建JedisPool。RedisConfig类继承了 JedisPoolConfig，并提供了 host,port等属性的包装，简单看一下RedisConfig的 属性： public class RedisConfig extends JedisPoolConfig {private String host = Protocol.DEFAULT_HOST;private int port = Protocol.DEFAULT_PORT;private int connectionTimeout = Protocol.DEFAULT_TIMEOUT;private int soTimeout = Protocol.DEFAULT_TIMEOUT;private String password;private int database = Protocol.DEFAULT_DATABASE;private String clientName;RedisConfig对象是由RedisConfigurationBuilder创建的，简单看下这个类的主要方法：public RedisConfig parseConfiguration(ClassLoader classLoader) { Properties config = new Properties();InputStream input =classLoader.getResourceAsStream(redisPropertiesFilename);if (input != null) {try {config.load(input);} catch (IOException e) {throw new RuntimeException("An error occurred while reading classpath property '"+ redisPropertiesFilename+ "', see nested exceptions", e);} finally {try {input.close();} catch (IOException e) {// close quietly}}}RedisConfig jedisConfig = new RedisConfig(); setConfigProperties(config, jedisConfig);return jedisConfig;}核心的方法就是parseConfiguration方法，该方法从classpath中读取一个redis.properties文件:host=localhostport=6379connectionTimeout=5000soTimeout=5000password=database=0clientName=并将该配置文件中的内容设置到RedisConfig对象中，并返回；接下来，就是RedisCache使用 RedisConfig类创建完成edisPool；在RedisCache中实现了一个简单的模板方法，用来操作Redis：private Object execute(RedisCallback callback) {Jedis jedis = pool.getResource();try {return callback.doWithRedis(jedis);} finally {jedis.close();}}模板接口为RedisCallback，这个接口中就只需要实现了一个doWithRedi s方法而已：public interface RedisCallback {Object doWithRedis(Jedis jedis);}接下来看看Cache中最重要的两个方法：putObject和getObject，通过这两个方法来查看mybatis-redis 储存数据的格式：@Overridepublic void putObject(final Object key, final Object value) {execute(new RedisCallback() {@Override public Object doWithRedis(Jedis jedis) {jedis.hset(id.toString().getBytes(), key.toString().getBytes(), SerializeUtil.serialize(value));return null;}});}@Overridepublic Object getObject(final Object key) {return execute(new RedisCallback() {@Overridepublic Object doWithRedis(Jedis jedis) {return SerializeUtil.unserialize(jedis.hget(id.toString().getBytes(), key.toString().getBytes()));}});}可以很清楚的看到，mybatis-redis在存储数据的时候，是使用的hash结构，把eache的id作为这个hash 的key (cache的id在mybatis中就是mapper的namespace)；这个mapper中的查询缓存数据作为 hash的field,需要缓存的内容直接使用SerializeUtil存储，SerializeUtil和其他的序列化类差不多，负责 对象的序列化和反序列化；第八部分Mybatis插件1. 插件简介一般情况下，开源框架都会提供插件或其他形式的拓展点，供开发者自行拓展。这样的好处是显而易见 的，一是增加了框架的灵活性。二是开发者可以结合实际需求，对框架进行拓展，使其能够更好的工 作。以MyBatis为例，我们可基于MyBatis插件机制实现分页、分表，监控等功能。由于插件和业务 无关，业务也无法感知插件的存在。因此可以无感植入插件，在无形中增强功能2. Mybatis插件介绍Mybatis作为一个应用广泛的优秀的ORM开源框架，这个框架具有强大的灵活性，在四大组件(Executor、StatementHandler、ParameterHandlers ResultSetHandler)处提供了简单易用的插 件扩展机制。Mybatis对持久层的操作就是借助于四大核心对象。MyBatis支持用插件对四大核心对象进 行拦截，对mybatis来说插件就是拦截器，用来增强核心对象的功能，增强功能本质上是借助于底层的 动态代理实现的，换句话说，MyBatis中的四大对象都是代理对象  MyBatis所允许拦截的方法如下：• 执行器Executor (update、query、commit、rollback等方法)；• SQL语法构建器StatementHandler (prepare、parameterize^ batch、update、query等方 法)；•参数处理器ParameterHandler (getParameterObject、setParameters方法)；•结果集处理器ResultSetHandler (handleResultSets、handleOutputParameters等方法)；3. Mybatis插件原理在四大对象创建的时候• 1、每个创建出来的对象不是直接返回的，而是interceptorChain.pluginAII(parameterHandler);• 2、获取到所有的Interceptor (拦截器)(插件需要实现的接口)；调用 interceptor, plugin(target);返回 target 包装后的对象• 3、插件机制，我们可以使用插件为目标对象创建一个代理对象；AOP (面向切面)我们的插件可 以为四大对象创建出代理对象，代理对象就可以拦截到四大对象的每一个执行；拦截插件具体是如何拦截并附加额外的功能的呢？以ParameterHandler来说public ParameterHandler newParameterHandler(MappedStatement mappedStatement, Object object, BoundSql sqlr Interceptorchain interceptorchain){ParameterHandler parameterHandler =mappedStatement.getLang().createParameterHandler(mappedStatementA object,sql); parameterHandler = (ParameterHandler)interceptorchain.pluginAll(parameterHandler);return parameterHandler;}public Object pluginAll(Object target) {for (Interceptor interceptor : interceptors) {target = interceptor.plugin(target);}return target;}interceptorChain保存了所有的拦截器(interceptors),是mybatis初始化的时候创建的。调用拦截器鍵 中的拦截器依次的对目标进行拦截或增强。interceptor.plugin(target)中的target就可以理解为mybatis 中的四大对象。返回的target是被重重代理后的对象如果我们想要拦截Executor的query方法，那么可以这样定义插件：@Intercepts({@Signature(type = Executor.class,method = "query",args ={MappedStatement.class, Object.class, RowBounds.classr ResultHandler.class})})public class Example?lugin implements Interceptor {//省略逻辑}除此之外，我们还需将插件配置到sqlMapConfig.xml中。<plugins><plugin interceptor=11 com. lagou.plugin.ExamplePlugin"></plugin></plugins>这样MyBatis在启动时可以加载插件，并保存插件实例到相关对象(InterceptorChain,拦截器鍵) 中。待准备工作做完后，MyBatis处于就绪状态。我们在执行SQL时，需要先通过 DefaultSqISessionFactory 创建 SqISession。Executor 实例会在创建 SqISession 的过程中被创建， Executor实例创建完毕后，MyBatis会通过JDK动态代理为实例生成代理类。这样，插件逻辑即可在 Executor相关方法被调用前执行。以上就是MyBatis插件机制的基本原理4. 自定义插件4.1插件接口Mybatis 插件接口-Interce pto r• Intercept方法，插件的核心方法• plugin方法，生成target的代理对象• setProperties方法，传递插件所需参数4.2自定义插件设计实现一个自定义插件^Intercepts ( {//注意看这个大花括号，也就这说这里可以定义多个(^Signature对多个地方拦截，都用 这个拦截器^Signature (type = StatementHandler.class, /扌旨拦截哪个扌妾口 method = "prepare"，//这个接口内的哪个方法名，不要拼错了 args = { Connection.class,工nteger.class} ),////这是拦截的方法的入 参，按顺序写到这，不要多也不要少，如果方法重载，可是要通过方法名和入参来确定唯一的})public class MyPlugin implements Interceptor {private final Logger logger = LoggerFactory.getLogger(this.getClass())；// //这里是每次执行操作的时候，都会进行这个拦截器的方法内@Overridepublic Object intercept(Invocation invocation) throws Throwable {〃增强逻辑System, out .printIn( 11 对方法进行了增强return invocation.proceed( ) ; //执彳亍原方法}* 11主要是为了把这个拦截器生成一个代理放到拦截器链中* ^Description包装目标对象 为目标对象创建代理对象* @Param target为要拦截的对象* ^Return代理对象*/@Overridepublic Object plugin(Object target) {System, out .print In ("将要包装的目标对象：ar get);  return Plugin.wrap(target,this);/**获取配置文件的属性**///插件初始化的时候调用，也只调用一次，插件配置的属性从这里设置进来 ^Overridepublic void setProperties(Properties properties) { System.out.println("插件配置的初始化参数："+properties );}}sqlMapConfig.xml<plugins><plugin interceptor="com.lagou.plugin.MySqlPagingPlugin"><!--配置参数一><property name="name" value="Bob"/></plugin></plugins>mapper 接口public interface UserMapper {List<User> selectUser();}mapper.xml<mapper namespace="com.lagou.mapper.UserMapper"><select id="selectUser" resultType="com.lagou.pojo.User"> SELECTid,usernameFROMuser</select></mapper>测试类public class PluginTest {@Testpublic void test() throws IOException { InputStream resourceAsStream =Resources.getResourceAsStream("sqlMapConfig.xml"); SqlSessionFactory sqlSessionFactory = newSqlSessionFactoryBuilder().build(resourceAsStream);  SqlSession sqlSession = sqlSessionFactory.openSession();UserMapper userMapper = sqlSession.getMapper(UserMapper.class);List<User> byPaging = userMapper.selectUser(); for (User user : byPaging) {System.out.println(user);}}}5. 源码分析执行插件逻辑Plugin实现了 InvocationHandler接口，因此它的invoke方法会拦截所有的方法调用。invoke方法会 对所拦截的方法进行检测，以决定是否执行插件逻辑。该方法的逻辑如下：// -Pluginpublic Object invoke(Object proxy, Method method, Object[] args) throws Throwable {try {/**获取被拦截方法列表，比如：*	signatureMap.get(Executor.class), 可能返回 [query, update, commit]*/Set<Method> methods = signatureMap.get(method.getDeclaringClass());//检测方法列表是否包含被拦截的方法if (methods != null && methods.contains(method)) {//执行插件逻辑return interceptor.intercept(new Invocation(target, method, args));//执行被拦截的方法return method.invoke(target, args);} catch (Exception e) {invoke方法的代码比较少，逻辑不难理解。首先,invoke方法会检测被拦截方法是否配置在插件的 ©Signature注解中，若是，则执行插件逻辑，否则执行被拦截方法。插件逻辑封装在intercept中，该 方法的参数类型为Invocationo Invocation主要用于存储目标类，方法以及方法参数列表。下面简单看 一下该类的定义public class Invocation {private final Object target;private final Method method;private final Object[] args;public Invocation(Object targetf Method method, Object[] args) {this.target = target;this.method = method;//省略部分代码public Object proceed() throws InvocationTargetException, IllegalAccessException {//调用被拦截的方法>> —关于插件的执行逻辑就分析结束6 pageHelper分页插件MyBati s可以使用第三方的插件来对功能进行扩展，分页助手PageHelpe r是将分页的复杂操作进行封 装，使用简单的方式即可获得分页的相关数据开发步骤：① 导入通用PageHelper的坐标② 在mybatis核心配置文件中配置PageHelper插件③ 测试分页数据获取① 导入通用PageHelper坐标<!--分页助手一><dependency><groupId>com.github.pagehelper</groupId><artifactId>pagehelper</artifactId><version>3.7.5</version></dependency><dependency><groupId>com.github.jsqlparser</groupId><artifactId>jsqlparser</artifactId><version>0.9.1</version></dependency>② 在mybatis核心配置文件中配置PageHelper插件<!--注意：分页助手的插件 配置在通用馆mapper之前—><plugin interceptor="com.github.pagehelper.PageHelper"> <!—指定方舌 —><property name="dialect" value="mysql"/></plugin>③ 测试分页代码实现@Testpublic void testPageHelper(){//设置分页参数PageHelper.startPage(1,2);List<User> select = userMapper2.select(null); for(User user : select){System.out.println(user);}}获得分页相关的其他参数〃其他分页的数据PageInfo<User> pageInfo = new PageInfo<User>(select);System.out.println("总条数："+pageInfo.getTotal());System.out.println("总页数："+pageInfo. getPages ());System.out.println("当前页："+pageInfo. getPageNum());System.out.println("每页显万长度："+pageInfo.getPageSize());System.out.println("是否第一页："+pageInfo.isIsFirstPage());System.out.println("是否最后一页："+pageInfo.isIsLastPage());7 通用 mapper什么是通用Mapper通用Mapper就是为了解决单表增删改查，基于Mybatis的插件机制。开发人员不需要编写SQL,不需要 在DAO中增加方法，只要写好实体类，就能支持相应的增删改查方法如何使用1. 首先在maven项目，在pom.xml中引入mapper的依赖<dependency><groupId>tk.mybatis</groupId><artifactId>mapper</artifactId><version>3.1.2</version></dependency>2. Mybatis配置文件中完成配置<plugins><!--分页插件：如果有分页插件，要排在通用mapper之前<plugin interceptor="com.github.pagehelper.PageHelper"><property name="dialect" value="mysql"/></plugin>--><plugin interceptor="tk.mybatis.mapper.mapperhelper.MapperInterceptor"> <!—通用Mapper接口，多个通用接口用逗号隔开—> <property name="mappers"value="tk.mybatis.mapper.common.Mapper"/></plugin></plugins>3. 实体类设置主键@Table(name = "t_user")public class User {@Id@GeneratedValue(strategy = GenerationType.IDENTITY)private Integer id;private String username;}4. 定义通用mapperimport com.lagou.domain.User;import tk.mybatis.mapper.common.Mapper;public interface UserMapper extends Mapper<User> {}5. 测试public class UserTest {@Testpublic void test1() throws IOException {Inputstream resourceAsStream = Resources.getResourceAsStream("mybatis- mapper-config.xml");SqlSessionFactory build = newSqlSessionFactoryBuilder().build(resourceAsStream);SqlSession sqlSession = build.openSession();UserMapper userMapper = sqlSession.getMapper(UserMapper.class);User user = new User();user.setId(4);//(1)mapper基础接口//select 接口User user1 = userMapper. selectOne (user ); //根据实体中的属性进行查询，只能有 —个返回值List<User> users = userMapper. select ( null); //查询全部结果userMapper. selectByPrimaryKey (1); //根据主键字段进行查询，方法参数必须包含完 整的主键属性，查询条件使用等号userMapper. selectCount (user ); //根据实体中的属性查询总数，查询条件使用等号// insert 接口int insert = userMapper. insert (user ); //保存一个实体，null值也会保存，不会使 用数据库默认值int i = userMapper. insertSelective (user ); //保存实体，null的属性不会保存， 会使用数据库默认值// update 接口int i1 = userMapper. updateByPrimaryKey (user );//根据主键更新实体全部字段， null值会被更新// delete 接口int delete = userMapper.delete(user); //根据实体属性作为条件进行删除，查询条件 使用等号userMapper. deleteByPrimaryKey (1); //根据主键字段进行删除，方法参数必须包含完 整的主键属性//(2)example方法Example example = new Example(User.class);example.createCriteria().andEqualTo("id",1);example.createCriteria().andLike("val", "1");//自定义查询List<User> users1 = userMapper.selectByExample(example);}}第九部分Mybatis架构原理9.1架构设计 事务唾我们把Mybatis的功能架构分为三层：(1) API接口层：提供给外部使用的接口 API，开发人员通过这些本地API来操纵数据库。接口层一接收到 调用请求就会调用数据处理层来完成具体的数据处理。MyBati s和数据库的交互有两种方式：a. 使用传统的MyBati s提供的API ；b. 使用Mapper代理的方式(2) 数据处理层：负责具体的SQL查找、SQL解析、SQL执行和执行结果映射处理等。它主要的目的是根 据调用的请求完成一次数据库操作。(3) 基础支撑层：负责最基础的功能支撑，包括连接管理、事务管理、配置加载和缓存处理，这些都是共 用的东西，将他们抽取出来作为最基础的组件。为上层的数据处理层提供最基础的支撑9.2主要构件及其相互关系构件描述SqlSession作为MyBatis工作的主要顶层API，表示和数据库交互的会话，完成必要数 据库增删改查功能ExecutorMyBatis执行器，是MyBatis调度的核心，负责SQL语句的生成和查询缓 存的维护StatementHandler封装了JDBC Statement操作，负责对JDBC statement的操作，如设置参 数、将Statement结果集转换成List集合。ParameterHandler负责对用户传递的参数转换成JDBC Statement所需要的参数，ResultSetHandler负责将JDBC返回的ResultSet结果集对象转换成List类型的集合；TypeHandler负责java数据类型和jdbc数据类型之间的映射和转换MappedStatementMappedStatement维护了一条＜select | update | delete | insert＞节点的封 装SqlSource负责根据用户传递的parameterObject，动态地生成SQL语句，将信息封 装到BoundSql对象中，并返回BoundSql表示动态生成的SQL语句以及相应的参数信息    9.3总体流程(1) 加载配置并初始化触发条件：加载配置文件配置来源于两个地方，一个是配置文件(主配置文件conf.xml,mapper文件*.xml),—个是java代码中的 注解，将主配置文件内容解析封装到Configuration,将sql的配置信息加载成为一个mappedstatement 对象，存储在内存之中(2) 接收调用请求触发条件：调用Mybati s提供的API传入参数：为SQL的ID和传入参数对象处理过程：将请求传递给下层的请求处理层进行处理。(3) 处理操作请求触发条件：API接口层传递请求过来传入参数：为SQL的ID和传入参数对象处理过程：(A) 根据SQL的ID查找对应的MappedStatement对象。(B) 根据传入参数对象解析MappedStatement对象，得到最终要执行的SQL和执行传入参数。(C) 获取数据库连接，根据得到的最终SQL语句和执行传入参数到数据库执行，并得到执行结果。(D) 根据MappedStatement对象中的结果映射配置对得到的执行结果进行转换处理，并得到最终的处理 结果。(E) 释放连接资源。(4) 返回处理结果将最终的处理结果返回。第十部分Mybatis源码剖析10.1传统方式源码剖析：源码剖析-初始化Inputstream inputstream = Resources.getResourceAsStream("mybatis-config.xml"); //这一行代码正是初始化工作的开始。SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(inputStream);进入源码分析：// 1.我们最初调用的buildpublic SqlSessionFactory build(InputStream inputStream) {〃调用了重载方法return build(inputStream, null, null);}// 2.调用的重载方法public SqlSessionFactory build(InputStream inputStream, String environment, Properties properties) {try {// XMLConfigBuilder是专门解析mybatis的配置文件的类XMLConfigBuilder parser = new XMLConfigBuilder(inputstream, environment, properties);//这里又调用了一个重载方法。parser.parse()的返回值是Configuration对象 return build(parser.parse());} catch (Exception e) {throw ExceptionFactory.wrapException("Error building SqlSession.", e)MyBatis在初始化的时候，会将MyBatis的配置信息全部加载到内存中，使用 org.apache.ibatis.session.Configu ratio n 实例来维护下面进入对配置文件解析部分：首先对Configuration对象进行介绍：Configuration对象的结构和xml配置文件的对象几乎相同。回顾一下xml中的配置标签有哪些：properties (属性)，settings (设置)，typeAliases (类型别名)，typeHandlers (类型处理 器)，objectFactory (对象工厂)，mappers (映射器)等Configuration也有对应的对象属性来封装它们也就是说，初始化配置文件信息的本质就是创建Configuration对象，将解析的xml数据封装到Configuration内部属性中/*** 解析 XML 成 Configuration 对象。*/public Configuration parse() {//若已解析，抛出BuilderException异常if (parsed) {throw new BuilderException("Each XMLConfigBuilder can only be used once.");}//标记已解析parsed = true;// 解析 XML configuration 节点 parseConfiguration(parser.evalNode("/configuration")); return configuration;}/***解析XML*/private void parseConfiguration(XNode root) {try {//issue #117 read properties first// 解析 <properties /> 标签 propertiesElement(root.evalNode("properties"));// 解析〈settings /> 标签Properties settings =settingsAsProperties(root.evalNode("settings"));//加载自定义的VFS实现类loadCustomVfs(settings);// 解析 <typeAliases /> 标签typeAliasesElement(root.evalNode("typeAliases"));//解析<plugins />标签pluginElement(root.evalNode("plugins"));// 解析 <objectFactory /> 标签objectFactoryElement(root.evalNode("objectFactory"));/ / N军析 <obj ectWrapperFactory /> 标签objectWrapperFactoryElement(root.evalNode("objectWrapperFactory"));/ / 解析 <reflectorFactory /> 标签reflectorFactoryElement(root.evalNode("reflectorFactory"));// 赋值 <settings /> 到 Configuration 属性settingsElement(settings);// read it after objectFactory and objectWrapperFactory issue #631/ / 解析 <environments /> 标签 environmentsElement(root.evalNode("environments"));/ / N军析 <database!dProvider /> 标签 databaseldProviderElement(root.evalNode("databaseldProvider")); // 解析 <typeHandlers /> 标签typeHandlerElement(root.evalNode("typeHandlers"));//解析<mappers />标签mapperElement(root.evalNode("mappers"));} catch (Exception e) {throw new BuilderExceptionf"Error parsing SQL MapperConfiguration. Cause: " + e, e);}}介绍一下MappedStatement ：作用：MappedStatement与Mapper配置文件中的一个select/update/insert/delete节点相对应。 mapper中配置的标签都被封装到了此对象中，主要用途是描述一条SQL语句。初始化过程：回顾刚开 始介绍的加载配置文件的过程中，会对mybatis-config.xml中的各个标签都进行解析，其中有mappers 标签用来引入mapper.xml文件或者配置mapper接口的目录。<select id="getUser" resultType="user" >select * from user where id=#{id}</select>这样的一个select标签会在初始化配置文件时被解析封装成一个MappedStatement对象，然后存储在 Configuration对象的mappedStatements属性中，mappedStatements 是一个HashMap,存储时key =全限定类名+方法名，value =对应的MappedStatement对象。•在configuration中对应的属性为Map<Stringz MappedStatement> mappedStatements = new StrictMap<MappedStatement> ("Mapped Statements collection")•在 XMLConfigBuilder 中的处理：private void parseConfiguration(XNode root) {try {//省略其他标签的处理 mapperElement(root.evalNode("mappers"));} catch (Exception e) {throw new BuilderException("Error parsing SQL Mapper Configuration.Cause: " + e r e);}}到此对xml配置文件的解析就结束了，回到步骤2.中调用的重载build方法// 5.调用的重载方法public SqlSessionFactory build(Configuration config) {//仓！］建了DefaultSqlSessionFactory7^^,传入Configuration，寸象。return new DefaultSqlSessionFactory(config);}源码剖析■执行SQL流程先简单介绍SqISession：Sq丄Session是一个接口，它有两个实现类：DefaultSqlSession (默认)和SqlSessionManager (弃用，不做介绍)Sq丄Session是MyBatis中用于和数据库交互的顶层类，通常将它与ThreadLoca丄绑定，一个会话使用一 个SqlSession,并且在使用完毕后需要closeo public class DefaultSqlSession implements SqlSession {private final Configuration configuration;private final Executor executor;SqlSession中的两个最重要的参数，configuration与初始化时的相同，Executor为执行器Executor：Executor也是一个接口，他有三个常用的实现类：BatchExecutor (重用语句并执行批量更新)ReuseExecutor (重用预处理语句prepared statements)SimpleExecutor (普通的执行器，默认) 继续分析，初始化完毕后，我们就要执行SQL了SqlSession sqlSession = factory.openSession();List<User> list =sqlSession.selectList("com.lagou.mapper.UserMapper.getUserByName");获得 sqlSession//6. 进入 o penSession 方法。public SqlSession openSession() {//getDefaultExecutorType()传递的是SimpleExecutorreturn openSessionFromDataSource(configuration.getDefaultExecutorType(), null, false);}//7. 进入。penSessionFromDataSource。//ExecutorType 为Executor的类型，TransactionIsolationLevel为事务隔离级别， autoCommit是否开启事务//openSession的多个重载方法可以指定获得的SeqSession的Executor类型和事务的处理 private SqlSession openSessionFromDataSource(ExecutorType execType, TransactionIsolationLevel level, boolean autoCommit) {Transaction tx = null;try {final Environment environment = configuration.getEnvironment();final TransactionFactory transactionFactory = getTransactionFactoryFromEnvironment(environment);tx = transactionFactory.newTransaction(environment.getDataSource(), level, autoCommit);〃根据参数创建指定类型的Executorfinal Executor executor = configuration.newExecutor(tx, execType);//返回的是 DefaultSqlSessionreturn new DefaultSqlSession(configuration, executor, autoCommit);} catch (Exception e) {closeTransaction(tx); // may have fetched a connection so lets call close()}执行 sqlsession 中的 api//8.进入selectList方法，多个重载方法。List<E> selectList(String statement)return this.selectList(statement, null);List<E> selectList(String statement, Object parameter) { this.selectList(statement, parameter, RowBounds.DEFAULT);public <E> List<E> selectList(String statement, Object parameter, RowBounds rowBounds) {try {//根据传入的全限定名+方法名从映射的Map中取出MappedStatement对象 MappedStatement ms = configuration.getMappedStatement(statement);//调用Executor中的方法处理//RowBounds是用来逻辑分页// wrapCollection(parameter)是用来装饰集合或者数组参数 return executor.query(ms, wrapCollection(parameter), rowBounds,Executor・NO_RESULT_HANDLER);} catch (Exception e) {throw ExceptionFactory.wrapException("Error querying database. Cause: + e, e);} finally {ErrorContext.instance().reset();}源码剖析-executor继续源码中的步骤，进入executor.query()/此方法在SimpleExecutor的父类BaseExecutor中实现public <E> List<E> query(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler) throws SQLException {//根据传入的参数动态获得SQL语句，最后返回用BoundSql对象表示BoundSql boundSql = ms.getBoundSql(parameter);//为本次查询创建缓存的KeyCacheKey key = createCacheKey(ms, parameter, rowBounds, boundSql); return query(ms, parameter, rowBounds, resultHandler, key, boundSql);}//进入query的重载方法中public <E> List<E> query(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql) throws SQLException {ErrorContext.instance().resource(ms.getResource()).activity("executing a query").object(ms ・ getId());if (closed) {throw new ExecutorException("Executor was closed・");}if (queryStack == 0 && ms.isFlushCacheRequired()) {clearLocalCache();}List<E> list;try {queryStack++;list = resultHandler == null ? (List<E>) localCache.getObject(key): null;if (list != null) {handleLocallyCachedOutputParameters(ms, key, parameter, boundSql);} else {//如果缓存中没有本次查找的值，那么从数据库中查询list = queryFromDatabase(ms, parameter, rowBounds, resultHandler, key, boundSql);}} finally {queryStack——;}if (queryStack == 0) {for (DeferredLoad deferredLoad : deferredLoads) { deferredLoad.load();}// issue #601deferredLoads.clear();if (configuration.getLocalCacheScope() == LocalCacheScope.STATEMENT) {// issue #482clearLocalCache();}}return list;}//从数据库查询private <E> List<E> queryFromDatabase(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql) throws SQLException {List<E> list;localCache.putObject(key, EXECUTION_PLACEHOLDER);try {//查询的方法list = doQuery(ms, parameter, rowBounds, resultHandler, boundSql);} finally {localCache.removeObject(key);}//将查询结果放入缓存localCache.putObject(key, list);if (ms.getStatementType() == StatementType.CALLABLE) { localOutputParameterCache.putObject(key, parameter);}return list;}// SimpleExecutor中实现父类的doQuery抽象方法public <E> List<E> doQuery(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql) throws SQLException {Statement stmt = null;try {Configuration configuration = ms.getConfiguration();//传入参数创建StatementHanlder对象来执行查询 StatementHandler handler = configuration.newStatementHandler(wrapper,msf parameter, rowBoundsr resultHandler, boundSql);//创建jdbc中的statement对象stmt = prepareStatement(handler, ms.getStatementLog());/ / StatementHandler®tj^bSreturn handler.query(stmtr resultHandler);} finally {closestatement(stmt);}}//创建Statement的方法private Statement prepareStatement(StatementHandler handler, Log statementLog) throws SQLException {Statement stmt;//条代码中的getConnection方法经过重重调用最后会调用openConnection方法，从连接池中获 得连接。Connection connection = getConnection(statementLog);stmt = handler.prepare(connection, transaction.getTimeout());handler.parameterize(stmt);return stmt;}//从连接池获得连接的方法protected void openConnection() throws SQLException {if (log.isDebugEnabled()) {log.debug("Opening JDBC Connection");}〃从连接池获得连接connection = dataSource.getConnection();if (level != null) {connection.setTransactionIsolation(level.getLevel());}上述的Executor.queryO方法几经转折，最后会创建一个StatementHandler对象,然后将必要的参数传 递给StatementHandler,使用StatementHandler来完成对数据库的查询，最终返回List结果集。从上面的代码中我们可以看出，Executor的功能和作用是：(1、根据传递的参数，完成SQL语句的动态解析，生成BoundSql对象，供StatementHandler使用； (2、为查询创建缓存，以提高性能(3、创建JDBC的Statement连接对象，传递给*StatementHandler*对象，返回List查询结果。源码剖析-StatementHandlerStatementHandler对象主要完成两个工作：•对于JDBC的PreparedStatement类型的对象创建的过程中，我们使用的是SQL语句字符串会包 含若干个？占位符，我们其后再对占位符进行设值。StatementHandler通过 parameterize(statement)方法对Statement 进行设值；• StatementHandler通过List query(Statement statement, ResultHandler resultHandler)方法来 完成执行Statement,和将Statement对象返回的resultSet封装成List；进入至ijStatementHandlerfi<]parameterize(statement)方法白勺实现：public void parameterize(Statement statement) throws SQLException {//使Parameter Handler对象来完成对Statement的设值parameterHandler•setParameters((PreparedStatement) statement);}**ParameterHandler^fl^setParameters ( PreparedStatement ps ) 实现*对某一个Statement进行设置参数*/public void setParameters(PreparedStatement ps) throws SQLException { ErrorContext.instance().activity("settingparameters").object(mappedStatement.getParameterMap().getld()); List<ParameterMapping> parameterMappings = boundSql.getParameterMappings();if (parameterMappings 1= null) {for (int i = 0; i < parameterMappings.size(); i++) {ParameterMapping parameterMapping = parameterMappings.get(i)；if (parameterMapping.getMode() 1= ParameterMode.OUT) {Object value;String propertyName = parameterMapping.getProperty();if (boundSql.hasAdditionalParameter(propertyName)) { // issue #448 ask first for additional paramsvalue = boundSql.getAdditionalParameter(propertyName);} else if (parameterObject == null) {value = null;} else if(typeHandlerRegistry.hasTypeHandler(parameterObject.getClass())) {value = parameterObject;} else {MetaObject metaObject =configuration.newMetaObject(parameterObject);value = metaObject.getValue(propertyName);}// 每——个Mapping者8有——^TypeHandler,木艮据TypeHand丄er•来对preparedStatement■进 行设置参数TypeHandler typeHandler = parameterMapping.getTypeHandler();JdbcType jdbcType = parameterMapping.getJdbcType();if (value == null && jdbcType == null) jdbcType = configuration.getJdbcTypeForNull();  //设置参数typeHandler.setParameter(ps, i + 1, value, jdbcType);}}从上述的代码可以看到,StatementHandler的parameterize(Statement)方法调用了 ParameterHandler 的 s etParameters(statement)方法，ParameterHandler的s etParameters(Statement )方法负责根据我们输入的参数，对statement对象的 ?占位符处进行赋值。进入^ ijStatementHandler 的 List query(Statement statement, ResultHandler resultHandler)方法的 实现：public <E> List<E> query(Statement statement, ResultHandler resultHandler) throws SQLException {// 1.调用preparedStatemnt。execute()方法，然后将resultSet交给ResultSetHandler处理PreparedStatement ps = (PreparedStatement) statement;ps.execute();//2.使用 ResultHandler 来处理 ResultSetreturn resultSetHandler.<E> handleResultSets(ps);}从上述代码我们可以看出，StatementHandler 的List query(Statement statement, ResultHandler resultHandler)方法的实现，是调用了 ResultSetHandler 的 handleResultSets(Statement)方法。 ResultSetHandler 的 handleResultSets(Statement)方法会将 Statement 语句执行后生成的 resultSet 结 果集转换成List结果集public List<Object> handleResultSets(Statement stmt) throws SQLException { ErrorContext.instance().activity("handlingresults").object(mappedStatement.getId());//多ResultSet的结果集合，每个ResultSet对应一个Object对象。而实际上，每 个 Object 是 List<Object> 对象。//在不考虑存储过程的多ResultSet的情况，普通的查询，实际就一个ResultSet，也 就是说，multipleResults最多就一个元素。final List<Object> multipleResults = new ArrayList<>();int resultSetCount = 0;//获得首个ResultSet对象，并封装成ResultSetWrapper对象 ResultSetWrapper rsw = getFirstResultSet(stmt);//获得ResultMap数组//在不考虑存储过程的多ResultSet的情况，普通的查询，实际就一个ResultSet，也 就是说，resultMaps就一个元素。List<ResultMap> resultMaps = mappedStatement.getResultMaps();  int resultMapCount = resultMaps.size(); validateResultMapsCount(rsw, resultMapCount); // 校马仓 while (rsw != null && resultMapCount > resultSetCount) {//获得ResultMap对象ResultMap resultMap = resultMaps.get(resultSetCount);//处理ResultSet，将结果添加到multipleResults中 handleResultSet(rsw, resultMap, multipleResults, null);//获得下一个ResultSet对象，并封装成ResultSetWrapper对象 rsw = getNextResultSet(stmt);//清理 cleanUpAfterHandlingResultSet();// resultSetCount ++ resultSetCount++;}//因为'mappedStatement.resultSets'只在存储过程中使用，本系列暂时不考虑，忽 略即可String[] resultSets = mappedStatement.getResultSets();if (resultSets != null) {while (rsw != null && resultSetCount < resultSets.length) { ResultMapping parentMapping =nextResultMaps.get(resultSets[resultSetCount]);if (parentMapping != null) {String nestedResultMapId = parentMapping.getNestedResultMapId();ResultMap resultMap =configuration.getResultMap(nestedResultMapId); handleResultSet(rsw, resultMap, null, parentMapping);}rsw = getNextResultSet(stmt); cleanUpAfterHandlingResultSet(); resultSetCount++;}}//如果是multipleResults单元素，则取首元素返回 return collapseSingleResultList(multipleResults);}10.2 Mapper代理方式：回顾下写法:  public static void main(String[] args) {//前三步都相同InputStream inputStream =Resources.getResourceAsStream("sqlMapConfig.xml");SqlSessionFactory factory = newSqlSessionFactoryBuilder().build(inputStream);SqlSession sqlSession = factory.openSession();//这里不再调用SqlSession的api,而是获得了接口对象，调用接口中的方法。UserMapper mapper = sqlSession.getMapper(UserMapper.class); List<User> list = mapper.getUserByName("tom");}思考一个问题，通常的Mapper接口我们都没有实现的方法却可以使用，是为什么呢？答案很简单动态 代理开始之前介绍一下MyBatis初始化时对接口的处理：MapperRegistry是Configuration中的一个属性， 它内部维护一个HashMap用于存放mapper接口的工厂类，每个接口对应一个工厂类。mappers中可以 配置接口的包路径，或者某个具体的接口类。<mappers><mapper class="com.lagou.mapper.UserMapper"/><package name="com.lagou.mapper"/></mappers>•当解析mappers标签时，它会判断解析到的是mapper配置文件时，会再将对应配置文件中的增删 改查标签	封装成MappedStatement对象，存入mappedStatements中。(上文介绍了)当判断解析到接口时，会建此接口对应的MapperProxyFactory对象存入HashMap中，key =接口的字节码对象，value =此接口对应的MapperProxyFactory对象。源码剖析-getmapperQ进入 sqlSession.getMapper(UserMapper.class)中//Def aultSqlSession 中的 getMapperpublic <T> T getMapper(Class<T> type) {return configuration.<T>getMapper(type f this);}//conf iguration 中的给getMapperpublic <T> T getMapper(Class<T> typet SqlSession sqlSession) {return mapperRegistry.getMapper(typet sqlSession);}/ /Mappe rRegis try A-1 W getMapperpublic <T> T getMapper(Class<T> typet SqlSession sqlSession) {//从 M&pperRegistxy 中的 HashMap 中拿MapperProxyFactoryfinal MapperProxyFactory<T> mapperProxyFactory = (MapperProxyFactory<T>) knownMappers.get(type);if (mapperProxyFactory == null) {throw new BindingException("Type " + type + " is not known to the MapperRegistry.");}try {//通过动态代理工厂生成示例。return mapperProxyFactory.newInstance(sqlSession);} catch (Exception e) {throw new BindingException("Error getting mapper instance. Cause: " + e, e);}}//MapperProxyFactory 类中的 newInstance 方法public T newInstance(SqlSession sqlSession) {//创建了 JDK动态代理的Handler类final MapperProxy<T> mapperProxy = new MapperProxy<>(sqlSession, mapperInterface, methodCache);//调用了重载方法return newInstance(mapperProxy);}//MapperProxy 类，实现了 InvocationHandler 接口 public class MapperProxy<T> implements InvocationHandler, Serializable {//省略部分源码private final SqlSession sqlSession;private final Class<T> mapperInterface;private final Map<Method, MapperMethod> methodCache;//构造，传入了 SqlSession，说明每个session中的代理对象的不同的！public MapperProxy(SqlSession sqlSession, Class<T> mapperInterface, Map<Method, MapperMethod> methodCache) {this.sqlSession = sqlSession;this.mapperInterface = mapperInterface;this.methodCache = methodcache;}//省略部分源码}源码剖析-invoke。在动态代理返回了示例后，我们就可以直接调用mapper类中的方法了，但代理对象调用方法，执行是 在MapperProxy中的invoke方法中public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {try {//如果是Object定义的方法，直接调用if (Object.class.equals(method.getDeclaringClass())) { return method.invoke(this, args);} else if (isDefaultMethod(method)) {return invokeDefaultMethod(proxy, method, args);}} catch (Throwable t) {throw ExceptionUtil.unwrapThrowable(t);}// 获得 MapperMethod 对象final MapperMethod mapperMethod = cachedMapperMethod(method);//重点在这：MapperMethod最终调用了执行的方法return mapperMethod.execute(sqlSession, args);}进入e xecut e方法：public Object execute(SqlSession sqlSession, Object[] args) {Object result;//判断mapper中的方法类型，最终调用的还是SqlSession中的方法switch (command.getType()) {case INSERT: {//转换参数Object param = method.convertArgsToSqlCommandParam(args);//执行INSERT操作// 转换 rowCountresult = rowCountResult(sqlSession.insert(command.getName(), param));break;}case UPDATE: {//转换参数Object param = method.convertArgsToSqlCommandParam(args); // 转换 rowCountresult = rowCountResult(sqlSession.update(command.getName(), param));break;}case DELETE: {//转换参数Object param = method.convertArgsToSqlCommandParam(args); // 转换 rowCountresult = rowCountResult(sqlSession.delete(command.getName(), param));  break;case SELECT://无返回，并且有ResultHandler方法参数，则将查询的结果，提交给 ResultHandler 进行处理if (method.returnsVoid() && method.hasResultHandler()) { executeWithResultHandler(sqlSession, args); result = null;//执行查询，返回列表} else if (method.returnsMany()) { result = executeForMany(sqlSession, args);//执行查询，返回Map} else if (method.returnsMap()) { result = executeForMap(sqlSession, args);//执行查询，返回Cursor} else if (method.returnsCursor()) { result = executeForCursor(sqlSession, args);//执行查询，返回单个对象} else {//转换参数Object param = method.convertArgsToSqlCommandParam(args); //查询单条result = sqlSession.selectOne(command.getName(), param); if (method.returnsOptional() &&(result == null ||!method.getReturnType().equals(result.getClass()))) { result = Optional.ofNullable(result);}}break;case FLUSH:result = sqlSession.flushStatements();break;default:throw new BindingException("Unknown execution method for: " + command.getName());}//返回结果为null，并且返回类型为基本类型，则抛出BindingException异常 if (result == null && method.getReturnType().isPrimitive() && !method.returnsVoid()) {throw new BindingException("Mapper method '" + command.getName() + " attempted to return null from a method with a primitive return type (" + method.getReturnType() + ").");}//返回结果return result;}  第十一部分设计模式虽然我们都知道有3类23种设计模式，但是大多停留在概念层面，Mybatis源码中使用了大量的设计模 式，观察设计模式在其中的应用，能够更深入的理解设计模式Mybati s至少用到了以下的设计模式的使用：模式mybatis 体现Builder模式例如SqlSessionFactoryBuilder、Environment;工厂方 法模式例如SqlSessionFactory、TransactionFactory、LogFactory单例模 式例如 ErrorContext 和 LogFactory；代理模 式Mybatis实现的核心，比如MapperProxy、ConnectionLogger，用的jdk的动态代理 还有executor.loader包使用了 cglib或者javassist达到延迟加载的效果组合模 式例如SqlNode和各个子类ChooseSqlNode等；模板方 法模式例如 BaseExecutor 和 SimpleExecutor，还有 BaseTypeHandler 和所有的子类例如 IntegerTypeHandler；适配器 模式例如Log的Mybatis接口和它对jdbc、log4j等各种日志框架的适配实现；装饰者 模式例如Cache包中的cache.decorators子包中等各个装饰者的实现；迭代器 模式例如迭代器模式PropertyTokenizer； 接下来对Builder构建者模式、工厂模式、代理模式进行解读，先介绍模式自身的知识，然后解读在 Mybatis中怎样应用了该模式。11.1 Builder构建者模式Builder模式的定义是"将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表 示。”，它属于创建类模式，一般来说，如果一个对象的构建比较复杂，超出了构造函数所能包含的范 围，就可以使用工厂模式和Builder模式，相对于工厂模式会产出一个完整的产品，Builder应用于更加 复杂的对象的构建，甚至只会构建产品的一个部分，直白来说，就是使用多个简单的对象一步一步构建 成一个复杂的对象例子：使用构建者设计模式来生产c omputer主要步骤： 1、将需要构建的目标类分成多个部件（电脑可以分为主机、显示器、键盘、音箱等部件）；2、	创建构建类；3、	依次创建部件；4、	将部件组装成目标对象1. 定义computerpublic class Computer {String displayer;String mainUnit;String mouse;String keyboard;public String getDisplayer() { return displayer;}public void setDisplayer(String displayer) { this.displayer = displayer;}public String getMainUnit() {return mainUnit;}public void setMainUnit(String mainUnit) { this.mainUnit = mainUnit;}public String getMouse() {return mouse;}public void setMouse(String mouse) { this.mouse = mouse;}public String getKeyboard() { return keyboard;}public void setKeyboard(String keyboard) { this.keyboard = keyboard;}@Overridepublic String toString() {  return "Computer{” +"displayer='H + displayer +	+", mainUnit='" + mainUnit + '\'' +", mouse='" + mouse + '\'' +", keyboard='" + keyboard + '\'' +ComputerBuilderpublic static class ComputerBuilder{private ComputerBuilder target =new ComputerBuilder();public Builder installDisplayer(String displayer){ target.setDisplayer(displayer);return this;}public Builder installMainUnit(String mainUnit){ target.setMainUnit(mainUnit);return this;}public Builder installMouse(String mouse){ target.setMouse(mouse);return this;}public Builder installKeybord(String keyboard){ target.setKeyboard(keyboard);return this;}public ComputerBuilder build(){return target;}}2•调用  public static void main(String[] args) {ComputerBuilder computerBuilder = new ComputerBuilder();computerBuilder. installDisplayer ("显万器"); computerBuilder. installMainUnit ("主机"); computerBuilder. installKeybord ("键盘"); computerBuilder.installMouse ("鼠标”);Computer computer = computerBuilder.Builder();System.out.println(computer);}Mybatis中的体现SqlSessionFactory 的构建过程：Mybatis的初始化工作非常复杂，不是只用一个构造函数就能搞定的。所以使用了建造者模式，使用了大 量的Builder，进行分层构造，核心对象Configuration使用了 XmlConfigBuilder来进行构造  在Mybatis环境的初始化过程中，SqlSessionFactoryBuilder会调用XMLConfigBuilder读取所有的 MybatisMapConfig.xml 和所有的 *Mapper.xml 文件，构建 Mybatis 运行的核心对象 Configuration 对 象，然后将该Configuration对象作为参数构建一个SqlSessionFactory对象。  private void parseConfiguration(XNode root) {try {//issue #117 read properties first》/解析<p roper ties />标签propertiesElement(root.evalNode("properties"));// 解析 <settings /> 标签Properties settings = settingsAsProperties(root.evalNode("settings")); //加载自定义的VFS实现类loadCustomVfs(settings);// 解析 <typeAliases /> 标签typeAliasesElement(root.evalNode("typeAliases"));//解析<plugins />标签pluginElement(root.evalNode("plugins"));// 解析 <objectFactory /> 标签objectFactoryElement(root.evaINode("obj ectFactory"));// 解析 <objectWrapperFactory /> 标签obj ectWrappe rFacto ryElement(root.evalNode("objectWrapperFactory"));// 解析 <reflectorFactory /> 标签reflectorFactoryElement(root.evalNode("reflectorFactory"));// 赋值 <settings /> 到 Configuration 属性settingsElement(settings);// read it after objectFactory and objectWrapperFadory issue #631// 解析 <environments /> 标签environmentsElement(root.evalNode("environments"));// 解析 <databaseIdProvider /> 标签 databaseldProviderElement(root.evalNode("databaseldProvider"));其中 XMLConfigBuilder 在构建 Configuration 对象时，也会调用 XMLMapperBuilder 用于读取 *Mapper 文件，而XMLMapperBuilder会使用XMLStatementBuilder来读取和build所有的SQL语句。//解析<mappers />标签mappe「Element(root.evalNode("mappers"));在这个过程中，有一个相似的特点，就是这些Builder会读取文件或者配置，然后做大量的XpathParser 解析、配置或语法的解析、反射生成对象、存入结果缓存等步骤，这么多的工作都不是一个构造函数所 能包括的，因此大量采用了 Builder模式来解决c • SqISessionFactoryBuilderm ■ build(Reader): SqISessionFactorym % build(Reader, String): SqISessionFactorym ■ build(Reader, Properties): SqISessionFactorym % build(Reader, String, Properties): SqISessionFactorym ■ build(lnputStream): SqISessionFactorym 仁 build(lnputStream, String): SqISessionFactorym ■ build(lnputStream, Properties): SqISessionFactorym 仁 build(lnputStream, String, Properties): SqISessionFactorym ■ build(Configuration): SqISessionFactorySqlSessionFactoryBuilder类根据不同的输入参数来构建SqlSessionFactory这个工厂对象11.2工厂模式在Mybati s中比如S qISessionFactory使用的是工厂模式，该工厂没有那么复杂的逻辑，是一个简单工厂 模式。简单工厂模式(Simple Factory Pattern)：又称为静态工厂方法(Static Factory Method)模式，它属于创 建型模式。在简单工厂模式中，可以根据参数的不同返回不同类的实例。简单工厂模式专门定义一个类来负责创建 其他类的实例，被创建的实例通常都具有共同的父类例子：生产电脑假设有一个电脑的代工生产商，它目前已经可以代工生产联想电脑了，随着业务的拓展，这个代工生产 商还要生产惠普的电脑，我们就需要用一个单独的类来专门生产电脑，这就用到了简单工厂模式。下面 我们来实现简单工厂模式：1. 创建抽象产品类我们创建一个电脑的抽象产品类，他有一个抽象方法用于启动电脑：public abstract class Computer {*产品的抽象方法，由具体的产品类去实现*/public abstract void start();}2. 创建具体产品类接着我们创建各个品牌的电脑，他们都继承了他们的父类Computer，并实现了父类的s tart方法：public class LenovoComputer extends Computer{ @Overridepublic void start() {System.out.println("联想电脑启动");}public class HpComputer extends Computer{@Overridepublic void start() {System.out.println("惠普电脑启动");}}3. 创建工厂类接下来创建一个工厂类，它提供了一个静态方法createCompute r用来生产电脑。你只需要传入你想生 产的电脑的品牌，它就会实例化相应品牌的电脑对象public class ComputerFactory {public static Computer createComputer(String type){Computer mComputer=null;switch (type) {case "lenovo":mComputer=new LenovoComputer();break;case "hp":mComputer=new HpComputer(); break;}return mComputer;}}客户端调用工厂类客户端调用工厂类，传入“hp”生产出惠普电脑并调用该电脑对象的start方法：public class CreatComputer {public static void main(String[]args){ ComputerFactory.createComputer("hp").start();}}Mybatis 体现：Mybatis中执行Sql语句、获取Mappers、管理事务的核心接口SqlSession的创建过程使用到了工厂模 式。有一个 SqlSessionFactory 来负责 SqlSession 的创建'•也 DefaultSqISessionFactorym % DefaultSqlSessionFactory(Configuration)m ■ openSession(): SqlSession 个SqISessionFactorym ■ openSession(boolean): SqlSession 个SqISessionFactorym ■ openSession(ExecutorType): SqlSession 个SqISessionFactorym ¥ openSession(TransactionlsolationLevel): SqlSession 个SqISesm ■ openSession(ExecutorType, TransactionlsolationLevel): SqISem ■ openSession(ExecutorType, boolean): SqlSession 个SqISessic m ■ openSession(Connection): SqlSession 个SqISessionFactory m ■ openSession(ExecutorType, Connection): SqlSession 个SqISem ■ getConfigurationO： Configuration 个SqISessionFactorySqlSessionFactory可以看到，该Factory的openSession ()方法重载了很多个，分别支持autoCommit、Executor、Transaction等参数的输入，来构建核心的SqlSession对象。在DefaultSqlSessionFactory的默认工厂实现里，有一个方法可以看出工厂怎么产出一个产品:private SqlSession openSessionFromDataSource(ExecutorType execType, TransactionIsolationLevel level, boolean autoCommit) {Transaction tx = null;try {final Environment environment = configuration.getEnvironment();final TransactionFactory transactionFactory = getTransactionFactoryFromEnvironment(environment);tx = transactionFactory.newTransaction(environment.getDataSource(), level, autoCommit);〃根据参数创建制定类型的Executorfinal Executor executor = configuration.newExecutor(tx, execType);//返回的是 DefaultSqlSessionreturn new DefaultSqlSession(configuration, executor, autoCommit);} catch (Exception e) {closeTransaction(tx); // may have fetched a connection so lets call close()throw ExceptionFactory.wrapException("Error opening session. Cause: " + e, e);} finally {ErrorContext.instance().reset();}}这是一个openSession调用的底层方法，该方法先从configuration读取对应的环境配置，然后初始 化 TransactionFactory 获得一个 Transaction 对象，然后通过 Transaction 获取一个 Executor 对象，最后通过configuration、Executor、是否autoCommit三个参数构建了 SqlSession11.3代理模式代理模式(Proxy Pattern):给某一个对象提供一个代理，并由代理对象控制对原对象的引用。代理模式 的英文叫做Proxy，它是一种对象结构型模式，代理模式分为静态代理和动态代理，我们来介绍动态代 理举例：创建一个抽象类，Person接口，使其拥有一个没有返回值的doSomething方法。/***抽象类人*/public interface Person {void doSomething();}创建一个名为Bob的Person接口的实现类，使其实现doSomething方法/***创建一个名为Bob的人的实现类*/public class Bob implements Person {public void doSomething() {System.out.println("Bob doing something!");}}(3)创建JDK动态代理类，使其实现InvocationHandler接口。拥有一个名为target的变量，并创建 getTa rget获取代理对象方法/*** JDK动态代理* 需实现 InvocationHandler 接口*/public class JDKDynamicProxy implements InvocationHandler {//被代理的对象Person target;// JDKDynamicProxy 构造函数public JDKDynamicProxy(Person person) {this.target = person;}//获取代理对象public Person getTarget() {return (Person)Proxy.newProxylnstance(target.getClass().getClassLoader(),target.getClass().getInterfaces(), this);}//动态代理invoke方法public Person invoke(Object proxy, Method method, Object[] args) throwsThrowable {//被代理方法前执行System.out.println("JDKDynamicProxy do something before!");//执行被代理的方法Person result = (Person) method.invoke(target, args);//被代理方法后执行System.out.println("JDKDynamicProxy do something after!");return result;}}创建JDK动态代理测试类J DKDynamicTest/*** JDK动态代理测试*/public class JDKDynamicTest {public static void main(String[] args) {System.out.println("不使用代理类，调用doSomething方法。");//不使用代理类Person person = new Bob();// 调用 doSomething 方法person.doSomething();System.out.println("	分割线		");System.out.println("使用代理类，调用doSomething方法。");//获取代理类Person proxyPerson = new JDKDynamicProxy(new Bob()).getTarget();// 调用 doSomething 方法proxyPerson.doSomething();}}Mybatis中实现：代理模式可以认为是Mybatis的核心使用的模式，正是由于这个模式，我们只需要编写Mapper.java接 口，不需要实现，由Mybatis后台帮我们完成具体SQL的执行。当我们使用Configuration的getMapper方法时，会调用mapperRegistry.getMapper方法，而该方法又 会调用 mapperProxyFactory.newInstance(sqlSession)来生成一个具体的代理：public class MapperProxyFactory<T> {private final Class<T> mapperInterface;private final Map<Method, MapperMethod> methodCache = new ConcurrentHashMap<Method, MapperMethod>();public MapperProxyFactory(Class<T> mapperInterface) { this.mapperInterface = mapperInterface;}public Class<T> getMapperInterface() {return mapperInterface;}public Map<Method, MapperMethod> getMethodCache() {return methodCache;  @SuppressWarnings("unchecked")protected T newInstance(MapperProxy<T> mapperProxy) {return (T) Proxy.newProxyInstance(mapperInterface.getClassLoader(), new Class[] { mapperInterface },mapperProxy);}public T newInstance(SqlSession sqlSession) {final MapperProxy<T> mapperProxy = new MapperProxy<T>(sqlSession, mapperInterface, methodCache);return newInstance(mapperProxy);}在这里，先通过T newInstance(SqlSession sqlSession)方法会得到一个MapperProxy对象，然后调用T newInstance(MapperProxy mapperProxy)生成代理对象然后返回。而查看MapperProxy的代码，可 以看到如下内容：public class MapperProxy<T> implements InvocationHandler, Serializable {^Overridepublic Object invoke(Object proxy, Method method, Object[] args) throws Throwable {try {if (Object.class.equals(method.getDeclaringClass())) {return method.invoke(this, args);} else if (isDefaultMethod(method)) {return invokeDefaultMethod(proxy, method, args);}} catch (Throwable t) {throw ExceptionUtil.unwrapThrowable(t);}final MapperMethod mapperMethod = cachedMapperMethod(method);return mapperMethod.execute(sqlSession, args);非常典型的，该MapperProxy类实现了InvocationHandler接口，并且实现了该接口的invoke方法。通 过这种方式，我们只需要编写Mapper.java接口类，当真正执行一个Mapper接口的时候，就会转发给 MapperProxy.invoke方法，而该方法则会调用后续的 sqlSession.cud>executor.execute>prepareStatement 等一系列方法，完成 SQL 的执行和返回

